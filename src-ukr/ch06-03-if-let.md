## Лаконічний контроль виконання конструкцією `if let`

Запис `if let` дозволяє вам комбінувати `if` та `let` менш багатослівно, щоб керувати значеннями, що відповідають одному шаблону, і ігнорувати інші. Розглянемо програму у Роздруку 6-6, що працює зі значенням `Option<u8>`, але хоче виконувтаи код лише у коли значення дорівнює трьом:

```rust
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) => println!("три"),
    _ => (),
}
```


<span class="caption">Роздрук 6-6: `match`, що виконує код лише зі значенням `Some(3)`</span>

Ми хочемо зробити щось зі значенням `Some(3)`, але не робити нічого з жодним іншим значенням `Some(u8)` чи значенням `None`. Щоб задовільнити вираз `match`, нам доводиться додати `_ => ()` після обробки єдиного варіанту, що явно є надлишковим для такої ситуації.

Натомість ми могли б записати це коротше за допомогою `if let`. Наступний код робить те саме, що й `match` з Роздруку 6-6:

```rust
# let some_u8_value = Some(0u8);
if let Some(3) = some_u8_value {
    println!("три");
}
```

`if let` приймає шаблон і вираз, розділені оператором `=`. Він працює так само, як і `match`, де вираз надається `match`, а шаблон - це перший рукав.

Використання `if let` означає, що вам треба менше набирати, менше ставити відступів і менше писати зайвого коду. Тим не менш, ви втрачаємо перевірку на вичерпність, до якої зобов'язує `match`. Вибір між `match` та `if let` залежить від того, щощо ви робите у конкретній ситуації і чи лаконічність варта втрати перевірки на вичерпність.

Іншими словами, ви можете вважати `if let` синтаксичним цукром для `match`, де код виконується лише для одного шаблону і ігнорує всі інші варіанти.

У `if let` можна також додати `else`. Блок коду, що іде після else - це той самий блок коду, що був би у випадку `_` у виразу `match`, еквіалентному нашому `if let` та `else`. Згадаємо визначення enum-а `Coin` у роздруку 6-4, де варіант `Quarter` також включав значення `UsState`. Якби ми захотіли полічити усі не-чвертаки, що трапляються нам, і в той же час виводити штат чвертаків, ми могли б зробити це за допомогою десь такого `match`:

```rust
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("Чвертак штату {:?}!", state),
    _ => count += 1,
}
```

Або ж ми могли скористатися вираз `if let` та `else` ось таким чином:

```rust
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
# let coin = Coin::Penny;
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("Чвертак штату {:?}!", state);
} else {
    count += 1;
}
```

Якщо ви маєте ситуацію, де логіка вашої програми надто багатослівна, щоб виражати її за допомогою `match`, пам'ятайте, що `if let` також лежить у вашій коробці інструментів Rust.

## Підсумок

Ми щойно розібрали, як використовувати enum-и для створення власних типів, які можуть бути одного з множини перелічених значень. Ми показали, як тип `Option<T>` зі стандартної бібліотеки допомагає використовувати систему типів для уникання помилок. Коли значення enum-а мають дані всередині, можна скористатися `match` чи `if let` щоб витягти і використати ці значення, залежно від того, скільки різних варіантів вам треба обробити.

Ваші програми Rust тепер можуть виражати концепції з проблемної області за допомогою struct-ів та enum-ів. Створення власних типів для використання у вашому API гарантує безпеку типів: компілятор забезпечить, що ваші функції отримають лише значення тих типів, на які ці функції очікують.

Для того, щоб створити добре організований API для ваших користувачів, що є очевидним у використанні і надає користувачам лише те, що їм потрібно, звернімося до модулів Rust.
