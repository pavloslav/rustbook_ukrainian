## Змінні і сталість

Як вже згадувалося у Розділі 2, усталено змінні є *сталими* (*immutable*). Це
- один з численних штурханців, якими Rust заохочує вас писати код, що користується перевагами у безпеці та швидкості, які надає Rust. Тим не менш, ви все ж маєте можливість зробити змінні несталими. Дослідимо, як і чому Rust заохочує вас надавати перевагу сталості, та чому ви можете захотіти відмовитися від цього.

Якщо змінна є сталою, це означає, що відколи значення стає прив'язаним до імені, ви не можете змінити це значення. Для прикладу згенеруємо новий проект з назвою *variables* у вашій теці *projects* за допомгою `cargo new variables`.

Потім, у новоствореній теці *variables*, відкрийте *src/main.rs* і замініть його код таким:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/src/main.rs}}
```

Збережіть і запустіть програму за допомогою `cargo run`. Ви дістанете повідомлення про помилку, як показано тут:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/output.txt}}
```

Цей приклад показує, як компілятор допомагає вам знаходити помилки у програмах. Хоча повідомлення компілятора про помилки й можуть бути неприємними, вони лише означають, що ваша програма ще не робить те, що ви хотіли, у безпечний спосіб; вони *не* означають, що ви поганий програміст! Досвідчені растацеанці також отримують повідомлення про помилки від компілятора.

Повідомлення вказує, що причиною помилки є те, що ми "не можемо присвоювати двічі сталій змінній `x`" (`cannot assign twice to immutable variable x`), бо ви намагалися присвоїти нове значення сталій змінній `x`.

Важливо, що ми отримали помилку часу компіляції, коли намагалися змінити значення, яке раніше визначили як стале, тому що ця ситуація може призвести до вад у програмі. Якщо одна частина нашого коду працює з припущенням, що значення не буде змінене, а інша частина нашого коду змінює це значення, можливо, що перша частина коду буде робити не те, для чого вона була зроблена. Цю причину вад важко відслідкувати після виявлення, особливо коли другий фрагмент коду змінює значення лише *час від часу*.

У Rust компілятор гарантує, що, якщо ми заявили, що змінна лишиться сталою, вона і дійсно не зміниться. Це означає, що коли ви читаєте і пишете код, вам не треба відстежувати, як і де значення може змінитися. Ваш код стає легше зрозуміти.

Але несталість може бути дуже корисною. Змінні є сталими тільки усталено; ми можемо зробити їх несталими, додавши `mut` перед ім'ям змінної. На додачу до дозволу змінювати це значення, це попереджає майбутніх читачим коду про ваші наміри, вказуючи, що інші частини коду будуть змінювати значення цієї змінної.

Наприклад, змінимо *src/main.rs* на такий код:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```
```

Запустивши програму ми отримаємо:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```

Застосувавши `mut`, ми дозволили змінити значення, прив'язане до `x`, з `5` на `6`. У деяких випадках вам захочеться робити змінні несталими, бо так зручніше писати код, ніж у реалізації з виключно сталими змінними.

Варто розглядати й інші аспекти, крім запобігання вадам. Наприклад, якщо ви використовуєте великі структури даних, змінювати екземпляр на місці може бути швидше, ніж копіювати і повертати наново виділений екземпляр. Для менших структур даних може бути зручнішим розмірковувати про код, написаний у більш функціональному стилі, з постійним створенням нових екземплярів, тому може бути варто знизити продуктивність заради збільшення ясності.

### Відмінності між змінними та константами

Неможливість змінити значення змінної може нагадати вам про іншу концепцію программування, що є в більшості мов: *константи*. Константи - це так само значення, прив'язані до імені, які не можна змінювати, але є кілька відмінностей між константами і змінними.

По-перше, використання `mut` з константами неможливе: константи не тільки усталено сталі, вони завжди сталі.

Константи проголошуються ключовим словом `const` замість `let`, і тип значення *має* явно позначатися. Ми розкажемо про типи і позначки типів у наступному розділі, ["Типи даних"][data-types]<!-- ignore-->, тому не хвилюйтеся зараз про деталі. Просто пам'ятайте, що тип констант треба зазначати завжди.

Константи можуть проголошуватися у будь-якій області видимості, у тому числі глобальній, що робить їх корисними для зберігання значеннь, шо використовуються у багатьох частинах вашого коду.

Остання відмнінність полягає в тому, що константи можуть набувати тільки значення константних виразів, а не результатів виклику функції чи інших значень, які можуть бути обчислені лише під час виконання програми.

Ось приклад проголошення константи, де константа зветься `MAX_POINTS`, а її значення є 100,000. (Угода про назви констант в Rust вимагає використання верхнього регістру із підкресленнями між словами, також підкреслення додаються в числові літерали для кращої читаності):

```rust
const MAX_POINTS: u32 = 100_000;
```

Константи діють протягом усього часу життя програми, у тій області видимості, де вони були проголошені. Це робить константи корисними для зберігання значень з предметної області вашого застосунку, про які необхідно знати багатьом частинам програми, наприклад, максимальна кількість балів, яку може отримати гравець чи швидкість світла.

Корисно давати назви жорстко заданим значення, що використовуються по всій програмі, позначаючи їх константами, щоб передати сенс цього значення тим, хто супроводжуватиме код. Це також корисно тим, що в коді буде тільки одне місце, яке буде необхідно змінити у разі потреби оновити жорстко задане значення.

### Затінення

Як ми бачили під час програмування гри - відгадайки в підрозділі [“Порівняння здогадки з таємним числом"]()<!-- 
ignore --> Розділу 2, можна проголошувати нові змінні із таким самим іменем, як і в раніше проголошених змінних, і нова змінна витісняє попередню змінну. Растацеанці кажуть, що перша змінна 

*затінена* другою, що означає, що при використанні змінної ми отримаємо значення другої змінної. Ми можемо затінити змінну за допомогою ключового слова `let` та імені цієї змінної:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

Ця програма спершу прив'язує `x` до значення `5`. Потім затінює `x` повторенням `let x =`, взявши початкове значення і додавши до нього `1`, так що значення `x` стає `6`. Третя інструкція `let` також затінює `x`, бере попереднє значення і множить його на `2`, надаючи `x` остатночного значення `12`. Якщо запустити цю програму, вона виведе:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```

Це відрізняється від позначення змінної `mut`, адже якщо ми знову не використаємо ключове слово `let`, отримаємо помилку часу компіляції, якщо випадково спробуємо переприсвоїти значення цієї змінної. Ми можемо перетворювати значення, але змінна буде сталою після виконання цих перетворень.

Інша різниця між `mut` та затіненням полягає в тому, що, оскільки коли ми пишемо знову ключове слово `let`, насправді ми створюємо нову змінну, тож можемо змінити тип значення, але залишити ім'я. Наприклад, хай наша програма просить користувача вказати, скільки пробілів має бути всередині якогось тексту, ввівши символи пробілу, але насправді ми хочемо зберігати це значення як число:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

Ця конструкція можлива, бо перша змінна `spaces` має стрічковий тип, а друга змінна `spaces`, що є повністю новою змінною, якій трапилося мати таке саме ім'я, має числовий тип. Затінення, таким чином, позбавляє нас необхідності придумувати різні імена, на кшталт `spaces_str` та `spaces_num`; натомість, ми можемо заново використати простіше ім'я `spaces`. Але якщо ми спробуємо скористатися `mut`, як показано далі, ми дістанемо помилку часу компіляції:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

Помилка каже, що  не можна змінювати тип змінної:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

Тепер, дослідивши, як працюють змінні, погляньмо, які типи данних вони можуть зберігати.
ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number

[data-types]: ch03-02-data-types.html#data-types
