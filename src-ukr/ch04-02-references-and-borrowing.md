## Посилання і позичання

Проблема з кодом, що використовує кортежі, в кінці попереднього розділу полягає в тому, що ми маємо повертати `String` у функцію, що викликає, щоб можна було використовувати `String` після виклику `calculate_length`, бо `String` переміщується до `calculate_length`.

Ось як визначити і використати функцію `calculate_length`, що приймає параметром *посилання* на об'єкт замість перебирати володіння значенням:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

По-перше, зауважте, що весь код із кортежами при визначення змінної та поверненні з функції зник. По-друге, зверніть увагу, що ми передаємо `&s1` у `calculate_length`, а у визначенні функції ми приймаємо `&String` замість `String`.

Ці амперсанди (символи &) - це *посилання*, і вони дозволяють нам посилатися на певне значення, не перебираючи володіння ним. Рисунок 4-5 показує це.

<img alt="&String s вказує на String s1" src="img/trpl04-05.svg" class="center" />

<span class="caption">Рисунок 4-5: `&String s` вказує на `String s1`</span>

> Примітка: операція, зворотня до помилання, зветься розкриттям посилань, і виконується оператором розкриття `*`. Ми побачимо деякі застосування цього оператора в Розділі 8 і обговоримо подробиці розкриття посилань у Розділі 15.

Розглянемо детальніше виклик функції:

```rust
# fn calculate_length(s: &String) -> usize {
#     s.len()
# }
let s1 = String::from("hello");

let len = calculate_length(&s1);
```

Запис `&s1` створює посилання, що *посилається* на значення `s1`, але не володіє ним. Оскільки воно не володіє, значення, на яке воно вказує, не буде знищене, коли посилання вийде з області видимості.

Так само, сигнатура функції використовує `&`, щоб показати, що тип параметру `s`
- посилання. Додамо трохи коментарів для пояснення:

```rust
fn calculate_length(s: &String) -> usize { // s - це посилання на String
    s.len()
} // s виходить з видимості. Але оскільки вона не володіє тим, на що 
  // посилається, нічого не відбувається.
```

Область видимості, де змінна `s` є дійсною, така сама, як і у будь-якого параметра функції, але те, на що вказує посилання, не припиняє свого існування при виході з видимості, бо функція ним не володіє. Параметри - посилання замість значень означають, що їй не доведеться повертати значення, щоб повернути володіння, бо вона не має володіння.

Використання посилань - параметрів функції зветься *позичанням*. Як і в справжньому життя, якщо особа володіє чимось, ви можете це позичити у неї, а коли річ вам стане не потрібна, треба її віддати.

Що ж станеться, якщо ми спробуємо змінити щось, що ми позичили? Спробуйте запустити код з Роздруку 4-4. Попередження: він не працює!

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```

<span class="caption">Роздрук 4-4: спроба змінити позичене значення</span>

Ось помилка:

```text
error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable
 --> error.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- use `&mut String` here to make mutable
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ cannot borrow as mutable
```

Посилання, так само, як і змінні, устано є сталими. Ми не можемо змінити щось, на що ми маємо посилання.

### Несталі посилання

Посилку в коді з Роздруку 4-4 можна виправити маленьким виправленням:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

По-перше, треба змінити `s`, щоб він став `mut`. Потім, нам треба створити нестале посилання за допомогою `&mut s` і прийняти це нестале посилання за допомогою `some_string: &mut String`.

Але несталі посилання мають одне велике обмеження: ви может емати лише одне нестале посилання на конкретний фрагмент даних у окремій області видимості. Цей код не спрацює:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;
```

Ось помилка:

```text
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> borrow_twice.rs:5:19
  |
4 |     let r1 = &mut s;
  |                   - first mutable borrow occurs here
5 |     let r2 = &mut s;
  |                   ^ second mutable borrow occurs here
6 | }
  | - first borrow ends here
```

Це обмеження дозволяє внесення змін лише під пильним контролем. Це те, із чим борються новачки-растаціанці, бо більшість мов дозволяють вам змінювати коли завгодно. Перевага цього обмеження в тому, що Rust запобігає гонитві за даними під час компіляції.

*Гонитва за даними* подібна до стану гонитви і стається, коли мають місце такі умови:

1. Два чи більше вказівників мають доступ до одних даних у один і той самий час.
1. Щонайменше один зі вказівників використовується для запису даних.
1. Не застосовується жодних механізмів синхронізації доступу до даних.

Гонитва за даними викликає невизначену поведінку та її може бути складно виявити та виправити при відстеженні під час виконання; Rust запобігає цій проблеми, бо вона не дозволяє навіть скомпілювати код із гонитвою!

Як завжди, ми можемо скористатися фігурними дужками, щоб створити нову область видимості, дозволивши багато несталих посилань, але не *одночасно*:

```rust
let mut s = String::from("hello");

{
    let r1 = &mut s;

} // r1 виходить із видимості, так що можна без проблем створювати нові 
  // посилання.

let r2 = &mut s;
```

Схоже правило існує для змішування сталих і несталих посилань. Цей код призводить до помилки:

```rust,ignore
let mut s = String::from("hello");

let r1 = &s; // без проблем
let r2 = &s; // без проблем
let r3 = &mut s; // ПРОБЛЕМА
```

Ось помилка:

```text
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
 --> borrow_thrice.rs:6:19
  |
4 |     let r1 = &s; // без проблем
  |               - immutable borrow occurs here
5 |     let r2 = &s; // без проблем
6 |     let r3 = &mut s; // ПРОБЛЕМА
  |                   ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
```

Отакої! Не виходить *також* мати нестале посилання, коли в нас є стале. Користувачі сталого посилання не очікують, що його значення несподівано зміниться прямо під час використання. Втім, багато сталих посилань допустимі, бо жоден з тих, хто прости читає дані, не може вплинути на те, що інші читають ці дані.

Хоча ці помилки часами і дратують, пам'ятайте, що це компілятор Rust вказує на потенційний баг завчасно (під час компіляції замість часу виконання) і точно вказує, де полягає проблема, замість змушувати вас відстежувати, чому іноді ваші дані не такі, як ви очікували.

### Завислі посилання

У мовах із вказівниками легко можна помилково створити *завислий вказівник* - вказівник, що посилається на місце в пам'яті, що було виділене комусь іще, звільнивши пам'ять, але залишивши вказівник на цю пам'ять. У Rust, натомість, компілятор гарантує, що посилання ніколи не стануть завислими: якщо маємо посилання на певні дані, компілятор пересвідчиться, що дані не вийдуть із області видимості до того, як вийде посилання на ці дані.

Спробуймо створтти зависле посилання, чому Rust запобігне помилкою компіляції:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

Ось помилка:

```text
error[E0106]: missing lifetime specifier
 --> dangle.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
```

Це повідомлення про помилку посилається на особливість, про яку ми ще не розповідали: *час життя* (*lifetime*). Ми обговоримо часи життя детальніше у Розділі 10. Але, якщо опустити частини про час життя, повідомлення містить ключ до того, чому цей код містить проблему:

```text
this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
```

```text
тип, що повертає ця функція, містить позичене значення, але немає значення, яке
воно може позичити.
```

Поглянемо ближче, що саме стається на кожному кроці коду `dangle`:

```rust,ignore
fn dangle() -> &String { // dangle повертає посилання на String

    let s = String::from("hello"); // s - це новий String

    &s // ми повертаємо посилання на String, s
} // s виходить із видимості і звільняється. Його пам'ять втрачена. Небезпечно!
```

Оскільки `s` був створений всередині `dangle`, коли код `dangle` завершується, `s` буде вивільнено. Але ми пробуємо повернути посилання на нього. Це означає, що це посилання буде вказувати на некоректний `String`! Так не можна. І Rust цього не допустить.

Рішення тут - повертати `String` безпосередньо:

```rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```

Це працює без проблем. Володіння переміщується, і нічого не звільняється.

### Правила посилань

Ще раз повторимо, що ми обговорили про посилання:

1. У будь-який час можна мати *лише одне*, а не обидва:
  * Одне нестале посилання.
  * Будь-яку кількість сталих посилань.
2. Посилання завжди мають бути коректними.

Далі ми поглянемо на інших тип посилань: зрізи.

