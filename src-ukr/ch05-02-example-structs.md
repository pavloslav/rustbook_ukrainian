## Приклад програми, що використовує структури

Щоб зрозуміти, де можна використовувати структури, напишемо програму, що обчислює площу прямокутника. Почнемо з окремих змінних, а потім рефакторизуємо її так, щоб вона використовувала структури.

За допомогою Cargo створімо проект, що зветься *rectangles*, для двійкової програми, яка прийматиме ширину і висоту прямокутника в пікселях і обчислюватиме його площу. Роздрук 5-8 показує коротку очевидну програму, що робить саме те, що треба:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "Площа прямокутника {} квадратних пікселів.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```


<span class="caption">Роздрук 5-8: Обчислення площі прямокутника, заданого шириною та висотою в окремих змінних</span>

Тепер запустимо програму командою `cargo run`:

```text
Площа прямокутника 1500 квадратних пікселів.
```

### Рефакторизація за допомогою кортежів

Хоча Роздрук 5-8 працює і знаходить площу прямокутника викликом функції `area` з обома вимірами, його можна покращити. Ширина і висота пов'язані одна з одною, бо вони описують один прямокутник.

Натомість поглянемо на сигнатуру функції `area`:

```rust,ignore
fn area(width: u32, height: u32) -> u32 {
```

Функція `area` має обчислювати площу одного прямокутника, але наша функція приймає два параметри. Параметри пов'язані між собою, але це ніде не виражено в нашій програмі. Для кращої читаності і керованості буде краще зґрупувати ширину і висоту разом. Ми вже обговорювали один зі способів, як це зробити, у підрозділі "Об'єднання значень у кортежі" Розділу 3: за допомогою кортежів. Роздрук 5-9 показує версію нашої програми із кортежами:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "Площа прямокутника {} квадратних пікселів.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```


<span class="caption">Роздрук 5-9: визначення ширини і висоти прямокутника кортежем</span>

З одного боку, ця програма краща. Кортежі додають трохи структурованості, і тепер ми передаємо лише один аргумент. Але з іншого боку ця версія менш зрозуміла: кортежі не мають назв для своїх елементів, тому наші обчислення тепер складніше зрозуміти, бо тепер доводиться індексувати частини кортежу.

Не має значення, якщо ми переплутаємо ширину і висоту при обчисленні площі, але якщо ми захочему намалювати прямокутник на екрані, це матиме значення! Нам доведеться пам'ятати, що ширина має в кортежі індекс 0, а висота - індекс 1. Якби хтось інший працював із цим кодом, йому довелося б до цього здогадатися і також пам'ятати. Можна лего забути чи переплутати ці значення, що призведе до помилки, оскільки ми не вказали сенс даних у коді.

### Рефакторизація зі структурами: додаємо сенс

Ми використовуємо структури, щоб додати сенс за допомогою "ярликів" до даних. Ми можемо перетворити наш кортеж на тип даних з іменами як для цілого, так і для частин, як показано в Роздруку 5-10:

<span class="filename">Файл: src/main.rs</span>

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "Площа прямокутника {} квадратних пікселів.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```

<span class="caption">Роздрук 5-10: визначення структури `Rectangle`</span>

Тут ми визначили структуру і назвали її `Rectangle`. Всередині `{}` ми визначили поля `width` та `height`, обидва типу `u32`. Далі в `main` ми створюємо окремий екземпляр `Rectangle` з шириною 30 і висотою 50.

Наша функція `area` тепер має визначення з одним параметром, який ми назвали `rectangle`, тип якого - стале позичення екземпляра структури `Rectangle`. Як ми вже казали в Розділі 4, ми можемо позичити структуру замість перебирати володіння ним. Таким чином `main` зберігає володіння і може продовжувати використовувати `rect1`, тому ми застосовуємо `&` у сигнатурі функції та при її виклику.

Функція `area` звертається до полів `width` та `height` екземпляру `Rectangle`. Сигнатура функції `area` тепер каже саме те, що ми мали на увазі: обчислити площу `Rectangle` за допомогою полів `width` та `height`. Це сповіщає, що ширина і висота пов'язані одна з іншою, і дає змістовні імена значенням замість індексів кортежу `0` та `1`. Чіткість досягнута.

### Додаємо корисну функціональність зі успадкованими рисами.

Було б непогано мати змогу виводити екземпляр нашого `Rectangle` при зневаджені програми і бачити значення його полів. Роздрук 5-11 намагається вжити макрос `println!` так само, як було в Розділах 2, 3 і 4:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 = {}", rect1);
}
```

<span class="caption">Роздрук 5-11: спроба вивести екземпляр `Rectangle`</span>

Якщо запустити цей код, ми дістанемо помилку із головним повідомленням:

```text
error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied
```

Макрос `println!` може виконувати багато різних видів форматувань, і уставно `{}` каже `println!` використати форматування, відоме як `Display`: вивести те, що призначене для читання кінцевим споживачем. Примітивні типи, з яким ми досі стикалися, усталено реалізують `Display`, оскільки є лише один спосіб, яким можна показати `1` чи якийсь інший примітивний тип користувачу. Але зі структурами вже не настільки очевидно, як `println!` має форматувати вивід, оскільки є багато можливостей виведення: потрібні коми чи ні? Чи треба виводити фігурні дужки? Чи всі поля слід показувати? Через цю невизначеність, Rust не намагається відгадати, чого ми хочемо, і структури не мають підготовленої реалізації `Display`.

Якщо ми подивимося помилки далі, то знайдемо цю корисну примітку:

```text
`Rectangle` cannot be formatted with the default formatter; try using
`:?` instead if you are using a format string
```

Давайте спробуємо! Виклик макросу `println!` тепер виглядає так: `println!("rect1 = {:?}", rect1);`. Додавання специфікатора `:?` в `{}` каже `println!`, що ми хочемо використати формат виведення, що зветься `Debug`. `Debug` - це риса, що дозволяє вивести нашу структуру у спосіб, зручний для розробників, щоб дивитися її значення під час зневадження коду.

Запустимо змінений код. Run the code with this change. Трясця! Все одно помилка:

```text
error[E0277]: the trait bound `Rectangle: std::fmt::Debug` is not satisfied
```

Але знову компілятор дає нам корисну примітку:

```text
`Rectangle` cannot be formatted using `:?`; if it is defined in your
crate, add `#[derive(Debug)]` or manually implement it
```

Rust *має* функціональність для виведення інформації для зневадження, та нам доведеться увімкнути її явним способом, щоб зробити її доступною для нашої структури. Щоб зробити це, додамо помітку `#[derive(Debug)]` прямо перед визначенянм структури, як показано в Роздруку 5-12:

<span class="filename">Файл: src/main.rs</span>

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 = {:?}", rect1);
}
```


<span class="caption">Роздрук 5-12: Додавання помітки для успадкування риси `Debug` і виведення екземпляру `Rectangle`, форматуваним для зневадження</span>

Коли ми знову запустимо програму, то не отримаємо жодної помилки і побачимо таке:

```text
rect1 = Rectangle { width: 30, height: 50 }
```

Чудово! Це не найкрасивіший вивід, але він показує значення всіх полів для екземпляру, що точно допоможе при зневадженні. Коли у нас є більші структури, корисно мати зручніший для читання вивід; в цих випадках, ми можемо використати `{:#?}` замість `{:?}` у стрічці `println!`. Якщо скористатися стилем `{:#?}` у цьому прикладі, вивід виглядатиме так:

```text
rect1 is Rectangle {
    width: 30,
    height: 50
}
```

Rust надає низку рис, які можна використати з поміткою `derive`, що можуть додати корисну поведінку проголошеним нами типам. Ці риси і їхня поведінка перераховані у Додатку C. Ми покажемо, як реалізовувати ці риси зі власною поведінкою, як і створювати свої власні риси, у Розділі 10.

Наша функція `area` дуже конкретна: вона вираховує лише площу прямокутників. Було б корисно прив'язати цю поведінку міцніше до структури `Rectangle`, оскільки вона не працює з іншими типами. Давайте подивимося, як ми можемо продовжити рефакторизувати цей код, перетворивши функцію `area` на *метод* `area`, визначений для нашого типу `Rectangle`.