## Додаток A: Ключові Слова

Цей список містить ключові слова, зарезервовані для поточного або майбутнього використання в мові Rust. Відтак, вони не можуть використовуватися як ідентифікатори (за винятком сирих ідентифікаторів, про які ми поговоримо в розділі “[Сирі ідентифікатори][raw-identifiers]”<!-- ignore -->). Ідентифікатори - це імена функцій, змінних, параметрів, полів структур, модулів, крейтів, констант, макросів, статичних значень, атрибутів, типів, трейтів і часів існування.

### Ключові Слова, що Наразі Використовуються

Нижче наведено список ключових слів, що наразі використовуються, з описом їхнього призначення.

* `as` - виконує примітивне перетворення типу, прибирає неоднозначність трейта, що містить елемент, або перейменовує елементи в інструкціях `use`
* `async` - повертає `Future` замість блокування поточного потоку
* `await` - призупиняє виконання, допоки результат `Future` не буде готовим
* `break` - негайно завершує цикл
* `const` - визначає константу чи константний вказівник
* `continue` - переходить до наступної ітерації циклу
* `crate` - у шляху модуля посилається на корінь крейта
* `dyn` - динамічна диспетчеризація трейтового об'єкта
* `else` - вказує альтернативний рукав для конструкцій керування `if` та `if let`
* `enum` - визначає енум
* `extern` - підключає зовнішню функцію або змінну
* `false` - булевий літерал "хиба"
* `fn` - визначає функцію чи тип вказівника на функцію
* `for` - перебирає елементи з ітератора, реалізує трейт або вказує більш значущий час існування
* `if` - виконує код залежно від умовного виразу
* `impl` - реалізує притаманну функціональність чи трейт
* `in` - частина синтаксису циклу `for`
* `let` - зв'язує змінну
* `loop` - створує цикл без умов зупинки
* `match` - зіставляє значення з шаблонами
* `mod` - визначає модуль
* `move` - передає замиканню володіння усіма захопленими значеннями
* `mut` - позначає мутабельність у посиланнях, вказівниках чи шаблонних зв'язуваннях
* `pub` - позначає публічну видимість полів структур, блоків `impl` або модулів
* `ref` - зв'язує за посиланням
* `return` - повертає значення з функції
* `Self` - псевдонім для типу, який ми визначаємо або реалізуємо
* `self` - суб'єкт методу або поточного модуля
* `static` - визначає час існування, що триває протягом усього часу виконання програми або глобальну змінну
* `struct` - визначає структуру
* `super` - посилається на батьківський модуль відносно поточного
* `trait` - визначає трейт
* `true` - булевий літерал "правда"
* `type` - визначає псевдонім типу чи асоційований тип
* `union` - визначає [об'єднання][union]<!-- ignore -->; є ключовим словом виключно при проголошенні об'єднання
* `unsafe` - позначає небезпечний код, функції, трейти чи реалізації
* `use` - вводить символи в область видимості
* `where` - позначає обмеження типу
* `while` - цикл з умовою зупинки

### Зарезервовані на Майбутнє Ключові Слова

Нижче наведено список ключових слів, що ще не мають функціональності, та є зарезервованими в Rust для можливого використання у майбутньому.

* `abstract`
* `become`
* `box`
* `do`
* `final`
* `macro`
* `override`
* `priv`
* `try`
* `typeof`
* `unsized`
* `virtual`
* `yield`

### Сирі Ідентифікатори

*Сирі ідентифікатори* - це синтаксис, що дозволяє використовувати ключові слова там, де зазвичай це заборонено. Для використання сирого ідентифікатора, додайте до ключового слова префікс `r#`.

Наприклад `match` є ключовим словом. Якщо ви спробуєте скомпілювати цю функцію, що використовує `match` як ім'я:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

то отримаєте таку помилку:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

Ця помилка показує, що не можна використовувати ключове слово `match` як ідентифікатор функції. Щоб використати `match` як назву функції, вам доведеться використати синтаксис сирого ідентифікатора, ось так:

<span class="filename">Файл: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

Цей код компілюється без помилок. Зверніть увагу, що префікс `r#` в імені функції є як у визначенні, так і там, де ми викликаємо цю функцію в `main`.

Сирі ідентифікатори дозволяють вам використовувати будь-яке слово як ідентифікатор, навіть якщо воно зарезервоване як ключове слово. Це надає нам більше свободи для вибору назв ідентифікаторів, а також дозволяє інтегруватися з програмами, написаними мовами, де ці слова не є ключовими. Крім того, сирі ідентифікатори дозволяють використовувати бібліотеки, що написані в іншому виданні Rust, ніж ваше. Наприклад, `try` не було ключовим словом у редакції 2015, але стало у редакції 2018. Якщо ви залежите від бібліотеки, що написана в редакції 2015 і має функцію `try`, вам знадобиться синтаксис сирого ідентифікатора, в цьому випадку `r#try`, щоб викликати цю функцію з коду в редакції 2018. Див. [Додаток E][appendix-e]<!-- ignore --> щоб отримати більше інформації про видання.

[raw-identifiers]: #raw-identifiers

[union]: ../reference/items/unions.html

[appendix-e]: appendix-05-editions.html
