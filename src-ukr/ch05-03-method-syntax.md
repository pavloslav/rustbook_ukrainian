## Синтаксис методів

*Методи* подібні до функцій: вони проголошуються ключовим словом `fn` і іменем, можуть мати параметри і повертати значення, і містять код, що виконується, коли їх викликають з деінде. Однак методи відрізняються від функцій тим, що визначені в контексті struct-а (чи enum-а, чи trait-об'єкта, про що піде мова в Розділах 6 та 17, відповідно), і їхнім першим параметром завжди є `self`, що представляє екземпляр структури, з якої викликається метод.

### Визначення методів

Давайте замінимо функцію `area`, що приймає параметром екземпляр `Rectangle`, на новий метод `area`, визначений на структурі `Rectangle`, як показано в Роздруку 5-13:

<span class="filename">Файл: src/main.rs</span>

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "Площа прямокутника {} квадратних пікселів.",
        rect1.area()
    );
}
```


<span class="caption">Роздрук 5-13: Визначення методу `area` на структурі `Rectangle`</span>

Щоб визначити функцію в контексті `Rectangle`, ми починаємо блок `impl` (*implementation*, "реалізація"). Потім ми переносимо функцію `area` до фігурних дужок після `impl` і змніюємо перший (а в цьому випадку єдиний) параметр на `self` у сигнатурі та повсюди в тілі. У `main`, де ми викликали функцію `area` і передавали аргументом `rect1`, тепер використаємо *синтаксис виклику метода*, щоб викликати метод `area` нашого екземпляру `Rectangle`. Назва методу іде після екземпляру: ми додаємо крапку, за якою - ім'я методу, дужки, і аргументи, якщо такі будуть.

У сигнатурі `area` ми використовуємо `&self` замість `rectangle: &Rectangle`, бо Rust знає, що тип `self` - `Rectangle`, оскільки цей метод знаходться в контексті `impl Rectangle`. Зверніть увагу, що нам все ще треба використовувати `&` перед `self`, так само, як із `&Rectangle`. Методи можуть перебирати володіння над `self`, позичати `self` як сталу чи несталу змінну, як і будь-який інший параметр.

Ми обрали `&self` з тих самих причин, що й `&Rectangle` у версії з функцією: ми не хочемо брати володіння, ми хочемо просто читати дані struct-а, не писати їх. Якби ми хотіли змінити екземпляр, для якого викликали метод, десь у методі, то перший параметр мав би бути `&mut self`. Методи, що беруть володіння над екземпляром за допомогою просто `self`, зустрічаються нечасто; ця техніка зазвичай використовується, коли метод перетворює `self` у щось інше і ми не хочемо, щоб оригінальний екземпляр використовувався після трансформації.

Основна перевага використання методів замість функцій, окрім використання синтаксису виклику метода та відсутності необхідності повторювати тип `self` у сигнатурі кожного метода - це організація. Ми збираємо все, що ми можемо зробити з екземпляром типа, в один блок `impl`, не примушуючи майбутніх користувачів нашого коду шукати можливостей використання `Rectangle` в різних місцях у нашій бібліотеці.

> ### А де ж оператор `->`?
> 
> У мовах на кшталт C++ використовується два різні оператори для виклику методів: `.` якщо метод викликається для об'єкта безпосередньо і `->`, якщо викликається метод для вказівника на об'єкт і спершу вказівник слід розіменувати. Іншими словами, якщо `object` - це вказівник, то `object->something()` робить те саме, що й `(*object).something()`.
> 
> Rust не має еквівалента оператора `->`; натомість, Rust має властивість, що зветься *автоматичне перетворення на посилання і розіменування* (*automatic referencing and dereferencing*). Виклик методів - це одне з небагатьох місць, де Rust застосовує цю поведінку.
> 
> Ось як вона працює: коли ви викликаєте метод `object.something()`, Rust автоматично додає `&`, `&mut` чи `*`, щоб `object`  відповідав сигнатурі методу. Іншими словами, наступне одначає те саме:
> 
> ```rust
> # #[derive(Debug,Copy,Clone)]
> # struct Point {
> #     x: f64,
> #     y: f64,
> # }
> #
> # impl Point {
> #    fn distance(&self, other: &Point) -> f64 {
> #        let x_squared = f64::powi(other.x - self.x, 2);
> #        let y_squared = f64::powi(other.y - self.y, 2);
> #
> #        f64::sqrt(x_squared + y_squared)
> #    }
> # }
> # let p1 = Point { x: 0.0, y: 0.0 };
> # let p2 = Point { x: 5.0, y: 6.5 };
> p1.distance(&p2);
> (&p1).distance(&p2);
> ```
> 
> Перший вираз виглядає чистішим. Це автоматичне перетворення на посилання працює, бо зрозуміло, що саме приймають методи - тип `self`. Якщо дати Rust назву методу і що він має приймати, то вона зрозуміє, читає метод (`&self`), змінює (`&mut self`) чи поглинає (`self`). Те, що при виклику методу позичання є неявним для об'єкта, з якого метод викликано, важливо для того, щоб робить володіння було зручним для практичного використання.

### Методи з більшою кількістю параметрів

Потренуємося у використанні методів, реалізувавши другий метод на struct-і `Rectangle`. Цього разу ми хочемо, щоб екземпляр `Rectangle` брав інший екземпляр `Rectangle` і повертав `true`, якщо другий `Rectangle` може повністю вміститися в `self`; як ні - має повернути `false`. Тобто ми хочемо, щоб програма, показана в Роздруку 5-14, працювала, коли ми визначимо метод `
can_hold`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Чи може rect1 вмістити rect2? {}", rect1.can_hold(&rect2));
    println!("Чи може rect1 вмістити rect3? {}", rect1.can_hold(&rect3));
}
```


<span class="caption">Роздрук 5-14: Демонстрація використання поки що ненаписаного методу `can_hold`</span>

Очікуваний вивід має виглядати як показано нижче, бо обидві розмірності `rect2` менші за розмірності `rect1`, але `rect3` ширший за `rect1`:

```text
Чи може rect1 вмістити rect2? true
Чи може rect1 вмістити rect3? false
```

Ми знаємо, що хочемо визначити метод, тож він буде написаний у блоці `impl 
Rectangle`. Метод буде зватися `can_hold`, і буде позичати сталий `Rectangle` параметром. Ми можемо зрозуміти, якого типу буде параметр, подивившися на код, що викликає метод: `rect1.can_hold(&rect2)` передає `&rect2`, тобто стало позичає `rect2`, екземпляр `Rectangle`. Це зрозуміло, бо нам треба лише читати `rect2` (а не писати, бо тоді б було потрібне нестале позичання), і ми хочемо, щоб `main` залишав собі володіння `rect2`, щоб його можна було використовувати після виклику методі `can_hold`. Значення, що повертає `can_hold`, буде булевого типу, а реалізація перевірить, чи ширина та висота `self` більші за відповідно ширину та висоту іншого `Rectangle`. Додамо метод `can_hold` до блоку `impl` з Роздруку 5-13, як показано в Роздруку 5-15:

<span class="filename">Файл: src/main.rs</span>

```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```


<span class="caption">Роздрук 5-15: Реалізація методу `can_hold` для`Rectangle`, що приймає інший екземпляр `Rectangle` параметром.</span>

Коли ми запустимо цей код з функції `main` у Роздруку 5-14, ми отримаємо вивід, який хотіли. Методи можуть приймати багато параметрів, які ми додаємо до сигнатури після параметру `self`, і ці параметри працюють так само, як у функціях.

### Асоційовані функції

Інша корисна властивість блоків `impl` полягає в тому, що в них можна визначати функції, що *не* приймають `self` параметром. Вони звуться *асоційованими функціями*, бо вони асоційовані зі struct-ом. Це саме функції, а не методи, бо вони не мають екземпляру struct-а, з яким працюють. Ви вже користалися асоційованою функцією `String::from`.

Асоційовані функції часто використовуються як конструктори, що повертають новий екземпляр struct-а. Наприклад, ми можемо написати асоційовану функцію, що матиме один параметр розміру і використовуватиме його і як ширину, і як висоту, щоб створити таким чиному квадратний `Rectangle`, не вказуючи одне й те саме значення двічі:

<span class="filename">Файл: src/main.rs</span>

```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}
```

Щоб викликати асоційовану функцію, ми використовуємо запис `::` з іменем struct-а, наприклад `let sq = Rectangle::square(3);`. Ця функція включена до простору імен struct-а: запис `::` використовується і для асоційованих функцій, і для просторів імен, створених модулями, про які ми поговоримо в Розділі 7.

### Множинні блоки `impl`

Кожен struct може мати багато блоків `impl`. Наприклад, Роздрук 5-15 тотжний коду, показаному в Роздруку 5-16, де кожен метод знаходиться у власному блоці `impl`:

```rust
# #[derive(Debug)]
# struct Rectangle {
#     width: u32,
#     height: u32,
# }
#
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```


<span class="caption">Роздрук 5-16: Роздрук 5-15, переписаний у кількох блоках `impl`</span>

Тут немає підстав розділяти ці методи у множинні блоки `impl`, але це коректний синтаксис. Ми побачимо випадок, де множинні блоки `impl` корисні, у Розділі 10, коли говоритимемо про узагальнені типи та trait-и.

## Підсумок

Struct-и дозволяють створювати власні типи, що мають значення для предментної області програми. Використовуючи структури, ми можемо зберігати пов’язані між собою фрагменти даних і називати кожен фрагмент, щоб зробити наш код зрозумілим. Методи дозволяють нам визначати поведінку, яку мають екземпляри наших структур, а асоційвані функції дають нам функціональність простору імен, прив'язаного до нашої структури, без потреби в її екземплярі.

Але struct-и не є єдиним способом, яким можна створювати власні типи: перейдімо до такої особливості Rust, як enum-и, щоб додати ще одне знаряддя до нашого інструментарію.
