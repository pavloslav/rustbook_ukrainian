## Привіт, Cargo!

Cargo - це система побудови та пакетний менеджер. Більшість Растацеанців 
використовуватимуть цей інструмент для керування проєктами Rust, бо Cargo 
виконує багато задач, таких, як побудова коду, завантаження бібліотек, від яких залежить ваш код, та побудова цих бібліотек (бібліотеки, потрібні коду,
звуться *залежностями* (*dependencies*).

Найпростіші програми Rust, як та, яку ми щойно написали, не мають жодних 
залежностей, тому, якби ми побудували проєкт Hello world за допомогою Cargo,
то скористалися б тільки тією частиною Cargo, що відповідає з побудову коду. 
Якщо ж писати складніші програми Rust, виникне потреба в залежностях, і якщо 
почати проєкт за допомогою Cargo, задовольнити її буде значно легше.

Оскільки переважна більшість проєктів Rust використовують Cargo, надалі в книзі
вважатиметься, що ви теж використовуєте Cargo. Cargo встановлюється з Rust, 
якщо ви скористалися офіційним встановлювачем, як сказано в підрозділі 
[“Встановлення”][installation]<!-- ignore --> Якщо ви встановили Rust у інший 
спосіб, можете перевірити, чи встановлений Cargo, ввівши це у свій термінал:

```console
$ cargo --version
```

Якщо ви побачите номер версії, то чудово! Але якщо ви бачите помилку на кшталт
`не знайдено команду`, вам слід звернутися до документації по вашому методу
встановлення, щоб визначити, як окремо встановити Cargo.

### Створення проєкту за допомогою Cargo

Створімо новий проєкт за допомогою Cargo і подивимося, як він відрізняється від
нашого початкового проєкту Hello World. Поверніться до вашої теки *projects* 
(чи іншої, де знаходиться ваш код) і введіть команди (незалежно від системи):

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

Перша команда створює нову теку, що зветься *hello_cargo*. Ми назвали наш 
проєкт *hello_cargo*, і Cargo створює свої файли у теці з такою назвою.

Перейдіть до теки *hello_cargo* і перегляньте файли, і ви побачите, що Cargo 
створив два файли і одну теку: *Cargo.toml* і теку *src* із файлом *main.rs* 

Також він розпочав новий репозиторій Git, додавши файл *.gitignore*. Файли Git не будуть створені, якщо ви запустите `cargo new` в уже створеному репозиторії Git; ви можете змінити цю поведінку за допомогою `cargo new --vcs=git`.

> Примітка: Git - це поширена система контролю версій. Ви можете сказати 
> `cargo new` використовувати іншу систему контролю версій чи не 
> використовувати жодної за допомогою прапорця `--vcs`. Запустіть
> `cargo new --help`, щоб побачити можливі варіанти.

Відкрийте файл *Cargo.toml* у будь-якому текстовому редакторі. Він має 
виглядати десь так, як показано у Роздруку 1-2:

<span class="filename">Файл: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Ваше Ім'я <email@example.com>"]
edition = "2018"

[dependencies]
```

<span class="caption">Роздрук 1-2: Вміст файлу *Cargo.toml*, створеного 
командою `cargo new`</span>

Це файл у форматі [*TOML*](https://toml.io)<!-- ignore --> (*Tom’s Obvious, 
Minimal Language* - "Томова очевидна мінімальна мова"), який Cargo використовує
як формат для конфігурації.

Перший рядок, `[package]` (пакет), це заголовок розділу, що показує, що 
наступні інструкції стосуються конфігурації пакету. Коли ми додамо більше 
інформації до цього файлу, ми додамо й інші розділи.

Наступні чотири рядки встановлюють конфігураційну інформацію, потрібну Cargo 
для компілювання вашої програми: ім'я, версію, хто її написав і яку редакцію 
Rust використовувати. Cargo бере ваше ім'я та адресу електронної пошти з 
налаштувань середовища, і якщо вони неправильні, можете їх виправити та 
зберегти файл. Про ключ `edition` детальніше розповідається в Додатку E.

Останній рядок, `[dependencies]`, розпочинає розділ, де можна вказувати 
залежності вашого проєкту. Пакети з кодом в Rust звуться *крейт*ами (*crate*).
Нам не потрібні інші крейти для цього проєкту, але вони знадобляться для 
першого проєкту у розділі 2, і тоді ж ми скористаємося цим розділом.

Тепер відкрийте файл *src/main.rs* і подивіться на його вміст:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo створила для вас “Hello World!”, точно такий, який ми написали в 
Роздруку 1-1! Поки що єдина відмінність між нашим попереднім проєктом та 
згенерованим Cargo полягає в тому, що Cargo розмістив код у теці *src*, і 
додав конфігураційний файл *Cargo.toml* в основній теці.

Cargo очікує, що вихідні файли будуть розташовані в теці *src*, а основна тека
міститиме лише README (ПРОЧИТАЙМЕНЕ), ліцензійну інформацію, конфігураційні 
файли і все таке, що не стосується вашого коду. Таким чином, використання 
Cargo допоможе вам зберегти свої проекти красивими та охайними. Все має своє 
місце, і все лежить на своїх місцях.

Якщо ви почали проєкт, що не використовує Cargo, як було із нашим проєктом
“Hello, world!” , його можна перетворити на проєкт із підтримкою Cargo, 
перемістивши код до теки *src* і створивши відповідний файл *Cargo.toml*.

### Побудова і запуск проєкту Cargo

Поглянемо, як відрізняється побудова і запуск програми “Hello, world!” за 
допомогою Cargo. З теки *hello_cargo*, побудуйте проєкт такими командами:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

Це створить виконанний файл *target/debug/hello_cargo* (чи
*target\debug\hello_cargo.exe* на Windows), який можна запустити такою 
командою:

```console
$ ./target/debug/hello_cargo # чи .\target\debug\hello_cargo.exe на Windows
Hello, world!
```

Якщо все пройшло добре, ви побачите в терміналі `Hello, world!`. Запуск `cargo 
build` уперше також призводить до створення Cargo нового файлу в головній теці 
проєкту, що зветься *Cargo.lock*. Цей файл відстежує конкретних версії 
залежностей вашого проєкту. Цей проєкт не має залежностей, тому він не надто 
великий. Вам не треба нічого самостійно робити із цим файлом, його вмістом 
займається Cargo.

Ми щойно побудували проєкт командою `cargo build` і запустили командою
`./target/debug/hello_cargo`, але також можна скористатися командою 
`cargo run`, щоб скомпілювати та запустити все за одну дію:

```text
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Зверніть увагу, що цього разу ми не побачили повідомлення про те, що Cargo 
компілює `hello_cargo`. Cargo зрозумів, що файли не змінилися, тому просто 
запустив двійковий файл. Якби ви змінили сирцевий код, Cargo б перебудував 
проєкт перед виконанням, і ви б побачили щось схоже на це:

```text
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Крім того, Cargo має команду `cargo check`. Ця команда швидко перевіряє ваш 
код, щоб переконатися, що він компілюється, але не створює виконанного файлу:

```text
$ cargo check
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Чому виконанний файл може бути непотрібним? `cargo check` зазвичай працює 
значно швидше за `cargo build`, бо повністю пропускає створення виконанного 
файлу. Якщо ви перевіряєте вашу роботу під час написанння коду, використання `
cargo check` прискорить роботу. Ось чому багато растацеанців запускають `cargo 
check` час від часу поки пишуть програму, щоб переконатися, що вона 
компілюються, а потім запускають `cargo build`, коли готові працювати з 
виконанним файлом.

Підіб'ємо підсумок. За допомогою Cargo:

* Ми можемо побудувати проєкт за допомогою `cargo build`.
- Ми можемо побудувати і запустити проєкт в одну дію за допомогою `cargo run`;
* Ми можемо побудувати проєкт без створення двійкового файлу для пошуку помилок за допомогою `cargo check`;
* Результат побудови Cargo розміщує не в одній теці із кодом, а в теці 
*target/debug*.

Додаткова перевага використання Cargo полягає в тому, що його команди однакові
незалежно від операційної системи, в якій ви працюєте. Тому з цього моменту ми
більше не надаватимемо окремих команд для Linux, macOS чи Windows.

### Побудова для випуску

Коли ваш проєкт нарешті готовий для релізу, ви можете запустити `cargo build
--release` для компіляції проєкту з оптимізаціями. Це створить виконанний файл 
у теці  *target/release* замість *target/debug*. Ці оптимізації дозволяють 
коду Rust працювати швидше, але сповільнюють процес компіляції. Ось чому є два 
різні профілі: один для розробки, щоб можна було перебудовувати часто і 
швидко, та інший для побудови фінальної програми, яку можна дати користувачеві,
яку не треба часто перебудовувати і яка буде виконуватися якомога швидше. Якщо 
ви перевіряєте швидкість виконання вашого коду, запускайте `cargo build 
--release` і перевіряйте виконанний файл у *target/release*.

### Cargo як стандарт

У простих проєктах Cargo надає не набагато більше можливостей за `rustc`, але в
подальшому вона виявить свою цінність, коли ваші програми стануть складнішими. 
У складних проєктах, що складаються з багатьох крейтів, набагато простіше 
координувати побудову за допомогою Cargo.

Хоча наш проєкт `hello_cargo` і нескладний, тепер він використовує багато 
інструментів, якими ви будете користуватися решту вашої кар'єри з Rust. 
Фактично, щоб працювати із будь-яким існуючим проєктом ви можете скористатися 
цими командами, щоб завантажити код за допомогою Git, перейти до теки проєкту 
і побудувати його:

```console
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```

Якщо ми хочете детальніше дізнатися про Cargo, зазирніть до [його документації][its documentation].

[its documentation]: https://doc.rust-lang.org/cargo/

## Підсумок

Це був непоганий початок вашої подорожі до Rust! У цьому розділі, ви навчилися:

* Встановлювати останню стабільну версію Rust за допомогою `rustup`;
* Оновлюватися до нової версії Rust;
* Відкривати локально встановлену документацію;
* Писати і запускти програму “Hello, world!” за допомогою `rustc` езпосередньо 
і через стандартний інструмент `cargo`.

Настав час побудувати більш змістовну програму, щоб призвичаїтися до читання 
та написання коду Rust. У Розділі 2 ми створимо програму для  відгадування 
числа. Якщо ви натомість бажаєте почати з вивчення, як загальні концепції 
програмування працюють в Rust, переходьте до Розділу 3, а потім поверніться до 
Розділу 2.

[installation]: ch01-01-installation.html#installation
