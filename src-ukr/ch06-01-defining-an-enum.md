## Визначення enum-а

Розглянемо ситуацію, яка може виникнути при програмуванні, і побачимо, чому enum-и корисні і краще за struct-и підходять для цієї ситуації. Нехай нам потрібно працювати із IP-адресами. Наразі використовується два стандарти IP-адрес, четверта та шотста версії. Інших варіантів для IP-адрес наша програма не зустріне, ми можемо *перелічити* (*enumerate*) усі можливі значення, звідси й назва для переліків.

Будь-яка IP-адреса може бути або версії 4, або версії 6, але не одночасно. Ця властивість IP-адрес робить enum відповідним засобом для цієї мети, бо значення enum-а можуть бути лише одним із варіантів. Адреси як четвертої, так і шостої версій засадничо є саме IP-адресами, і з ними можна працювати як з одним типом, коли код стосується ситуацій, де можуть використовуватися обидва типи адрес.

Цю концепцію можна виразити, визначивши перелік `IpAddrKind` і перерахувавши можливі типи IP-адрес, `V4` та `V6`. Це зветься *варіантами* enum-а:

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

`IpAddrKind` тепер є користувацьким типом даних, яким ми можемо користуватися деінде в нашому коді.

### Значення Enum-а

Ми можемо створити екземпляри обох варіантів `IpAddrKind` таким чином:

```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

Зверніть увагу, що варіанти enum-а знаходяться у просторі імен його ідентифікатора, і для з'єднання ми використовуємо подвійну двокрапку. Це корисно, бо значення `IpAddrKind::V4` і `IpAddrKind::V6` належать до одного типу `IpAddrKind`. Тепер можна, скажімо, визначити функцію, що приймає `
IpAddrKind`:

```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
fn route(ip_type: IpAddrKind) { }
```

І викликати цю функцію для будь-якого з варіантів:

```rust
# enum IpAddrKind {
#     V4,
#     V6,
# }
#
# fn route(ip_type: IpAddrKind) { }
#
route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

Але використання enum-ів дає ще більше переваг. Наразі ми не маємо способу збергіати власне *дані* IP-адреси; ми знаємо лише її *тип*. Оскільки ми щойно дізналися про struct-и у Розділі 5, можна спробувати вирішити цю проблему, як показано у Роздруку 6-1:

```rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
```


<span class="caption">Роздрук 6-1: зберігання даних і варіанту `IpAddrKind` IP-адреси за допомогою `struct`</span>

Так ми визначили struct `IpAddr`, що має два поля: `kind` ("тип") типу `
IpAddrKind` (щойно визначений нами enum) та `address` типу `String`. Ми маємо два екземпляри цьго struct-а. Перший, `home`, має значення `kind` `
IpAddrKind::V4` і прив'язані дані адреси `127.0.0.1`. Другий екземпляр, `
loopback`, має інший варіант `IpAddrKind` значення поля `kind` - `V6`, і має прив'язану адресу `::1`. Ми використали struct, щоб пов'язати значення `kind` та `address` разом, таким чином варіант тепер прив'язаний до значення.

Цю концепцію можна представити у коротший спосіб за допомогою самого enum-а, а не enum-а всередині struct-а, розмістивши дані безпосередньо в кожному варіанті enum-а. Це нове визначення enum-а `IpAddr` каже, що обидва варіанти `V4` та `V6` мають прив'язані значення `String`:

```rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```

Ми причепили дані безпосередньо до кожного варіанту enum-а, і тепер нема потреби в додатковому struct-і.

Є ще одна перевага у використанні enum-а замість struct-а: кожен варіант може мати різні типи і кількість прив'язаних даних. IP-адреси четвертої версії завжди складаються з чотрирьох числових компоненів зі значеннями між 0 та 255. Якщо ми хочемо зберігати адреси `V4` як чотири значення `u8`, але `V6` - як `String`, то struct-ом ми цього зробити не зможемо. Натомість enum-и легко пораються із цим:

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```

Ми продемонстрували кілька різних можливостей, як можна представити IP-адреси двох різних типів у нашому коді за допомогою enum-а. Однак, як виявляється, бажання зберігати IP-адреси і кодувати їхній тип настільки поширене, що [стандартна бібліотека вже містить визначення, яке можна використати!][IpAddr]
<!-- ignore --> Подивимоя, як стандартна бібліотека визначає `IpAddr`: там є точно такий enum і варіанти, як і ті, що ми визначили, але дані адрес всередині варіантів представлені двома різними struct-ами, які визначені окремо для кожного варіанту:

```rust
struct Ipv4Addr {
    // деталі пропущено
}

struct Ipv6Addr {
    // деталі пропущено
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

Цей код показує, що ми можемо помістити будь-який вид даних всередину варіанту enum-а: стрічки, числові типи, struct-и тощо. Можна навіть вкласти інший enum! Також типи стандартної бібліотеки часто не набагато складніші за те, що ви б могли самі придумати.

Зверніть увагу, що хоча стандартна бібліотека містить визначення `IpAddr`, ми можемо створити і користуватися нашим власним визначенням без конфлікту, бо ми не ввели визначення зі стандартної бібліотеки у межі дії програми. Детальніше про введення в межі дії розглядається в Розділі 7.

Поглянемо на ще один приклад enum-а у Роздруку 6-2. Він має багато різноманітних типів, включених у варіанти:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```


<span class="caption">Роздрук 6-2: Enum `Message` ("повідомлення"), варіанти якого містять різну кількість та типи значень</span>

Цей enum має чотири варіанти різних типів:

* `Quit` ("вийти") не має пов'язаних даних.
* `Move` ("перейти") має всередині анонімний struct.
* `Write` ("написати") включає один `String`.
* `ChangeColor` ("змінити колір") включає три значення `i32`.

Визначення enum-а з варіантами, схожими на наведені у Роздруку 6-2, нагадує визначення різних типів struct-ів, але enum не використовує ключового слова `
struct` і всі варіанти згруповані разом у одному типі `Message`. Наступні struct-и могли б зберігати ті самі дані, що й варіанти попереднього enum-а:

```rust
struct QuitMessage; // struct - unit
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // struct - кортеж
struct ChangeColorMessage(i32, i32, i32); // struct - кортеж
```

Але якби ви використали окремі структури, кожна з яких має свій власний тип, нам було б складно визначити функцію, що могла б приймати ці повідомлення так, як ми можемо приймати enum `Message`, визначений в Роздруку 6-2, що є одним типом.

Enum-и та struct-и мають ще одну спільну рису: так само, як ми можемо оголошувати методи на struct-ах за допомогою `impl`, ми можемо так само їх оголошувати на enum-ах. Ось метод, що зветься `call`, який можна визначити на нашому enum-і `Message`:

```rust
# enum Message {
#     Quit,
#     Move { x: i32, y: i32 },
#     Write(String),
#     ChangeColor(i32, i32, i32),
# }
#
impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```

Тіло методу використає `self`, щоб отримати значення, для кого було викликано метод. У цьому прикладі ми створили змінну `m`, що має значення `Message::Write(String::from("hello"))`, і саме цей `self` буде в тілі методу `call` коли буде виконано `m.call()`.

Тепер розглянемо інший, дуже поширений і корисний enum зі стандартної бібліотеки: `Option`.

### Enum `Option` і його переваги над null-значеннями

У попередньому підрозділі ми розглянули, як enum `IpAddr` дозволяє нам використовувати систему типів Rust, щоб представляти більше інформації, ніж просто дані, у нашій програмі. Цей підрозділ розглядає використання `Option`, ще одного enum-а, визначеного в стандартній бібліотеці. Тип `Option` використовується в багатьох випадках, бо він представляє дуже поширену ситуацію, де значення може бути чи його може не бути. Те, що ця концепція виражена в системі типів, означає, що компілятор може перевірити, що ви обробили всі можливі варіанти, які потребують обробки, що запобігає вкрай поширеним в інших мовах програмування вадам.

Мову програмування часто оцінюють за тим, які особливості в ній є; але особливості, яких свідомо уникли, також важливі. Rust не має такої особливості, як null, що є в багатьох інших мовах. *Null* ("нульо") - це значення, що означає відсутність значення. У мовах із null змінні завжди можуть бути в одному з двох станів: null і не-null.

У книзі "Нульовий вказівник: помилка на мільярд доларів" винахідник null Тоні Гоар каже:

> Я називаю це моєю помилкою на мільярд доларів. На той момент я розробляв першу всеосяжну систему типів для посилань у об'єктно-орієнтованій мові. Моєю метою було переконатися, що всі використання посилань будуть абсолютно безпечними, з автоматичною перевіркою компілятором. Але я не міг опиратися спокусі додати нульове посилання просто тому що його було так легко реалізувати. Це призвело до незчислених помилок, вразливостей і системних збоїв, які, мабуть, коштували мільярд доларів болю і шкоди за останні 40 років.

Проблема з null-значеннями полягає в тому, що якщо ви спробуєте використовувати значення, яке є null ніби це не-null, ви дістанете помилку. А оскільки ця властивість присутня всюди, стає неймовірно просто помилитися таким чином.

Утім, коцепція, яку намагається виразити null, корисна: null - це значення, яке на цей момент є некоректним чи відсутнім з певних причин.

Проблема не в самій концепції, а в конкретній реалізації. Відтак Rust не має null-значень, але має enum, що представляє концепцію присутнього чи відсутнього значення. Цей enum - `Option<T>`, і він [визначений у стандартній бібліотеці][option]<!-- ignore --> ось так:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Enum `Option<T>` настільки корисний, що він включений у прелюдію; вам не потрібно явно вводити його в межи дії програми. На додачу також введені і його варіанти: можна використовувати `Some` та `None` напряму без префіксу `Option::`. Утім `Option<T>` - це лише звичайний enum, а `Some(T)` та `None` - варіанти типу `Option<T>`.

Запис `<T>` - особливість Rust, про яку ми ще не говорили. Це параметр узагальненого типу, і детальніше ми розглянемо узагальнення в Розділі 10. Поки що все, що вам слід знати - що `<T>` означає, що варіант `Some` enum-а `Option` може вміщати одне значення даних будь-якого типу. Ось деякі приклади використання значень `Option` для зберігання числових типів і стрічкових типів:

```rust
let some_number = Some(5);
let some_string = Some("стрічка");

let absent_number: Option<i32> = None;
```

Якщо ви використовуємо `None`, а не `Some`, треба повідомляти Rust, який саме тип `Option<T>` нам потрібен, бо компілятор не може вивести тип, який буде знаходитися в варіанті `Some`, за одним лиш значенням `None`.

Коли у нас є значення `Some`, ми знаємо, що значення наявне, і значення зберігається в варіанті `Some`. Коли є значення `None`, у певному сенсі, це означає те саме, що й null: ми не маємо придатного значення. То чим же `Option<T>` кращий за значення null?

У двох словах, оскільки `Option<T>` і `T` (де `T` може бути будь-яким типом) - різні типи, компілятор не дозволить нам використовувати значення `Option<T>` так, ніби ми маємо коректний тип. Наприклад, цей код не скомпілюється, бо він намагається додати `i8` до `Option<i8>`:

```rust,ignore
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

Якщо ми запустимо цей код, ми дістанемо повідомлення про помилку на кшталт цього:

```text
error[E0277]: the trait bound `i8: std::ops::Add<std::option::Option<i8>>` is
not satisfied
 -->
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option<i8>`
  |
```

Сильно! Насправді це повідомлення про помилку означає, що Rust не розуміє, як додати `i8` та `Option<i8>`, оскільки вони різного типу. Коли у нас у Rust є значення типу на кшталт `i8`, компілятор гарантує, що у нас завжди є справжнє значення. Ми можемо діяти впевнено без потреби у перевірці на null перш ніж використовувати це значення. Тільки тоді, коли у нас є `Option<i8>` (або будь-який тип чи значення, з яким ми працюємо), ми маємо турбуватися про те, що, можливо, значення не буде, і компілятор переконається, що ми обробляємо цей випадок, перш ніж використовувати значення.

Іншими словами, перед тим, як виконувати операції, які можна робити з `T`, треба перетворити значення `Option<T>` на `T`. В цілому це допомагає перехопити одну з найпоширеніших проблем із null - припущення, що щось не є null, коли насправді воно null.

Відсутність потреби турбуватися про пропущене припущення про не-null значення допомагає вам бути певнішим у власному коді. Щоб значення могло бути null, вам треба явно це вказати зробивши тип цього значення `Option<T>`. Потім, коли ви використовуєте це значення, від вас вимагається явно обробити випадок, коли це значення null. Всюди, де значення має тип, відмінний від `Option<T>`, ви *можете* безпечно припустити що це значення не null. Це свідоме рішення при розробці Rust для обмеження передавання null і збільшення безпеки коду Rust.

Але як же отримати значення `T` з варіанту `Some`, коли ви маєте значення типу `Option<T>`, щоб його використати? Enum `Option<T>` має велику кількість методів, зручних у різноманітних ситуаціях; ви можете подивитися їх у [ документації до `Option<T>`][docs]<!-- ignore -->. Ознайомлення з методами `Option<T>` буде вкрай корисним для вашого вивчення Rust.

В цілому, щоб скористатися значенням `Option<T>`, ми хочемо мати код, що обробить обидва варіанти. Ми хочемо, щоб певний код виконувався лише для значень `Some(T)`, і цей код може використовувати внутрішнє `T`. І ми хочемо, щоб інший код виконувався, коли ми маємо значення `None`, і цей код не має доступу до значення `T`. Вираз `match` - це конструкція управління, що саме це й робить, коли використовується з enum-ами: воно виконає різний коді залежно від варіанту enum-а, і цей код може використовувати дані всередині відповідного значення.

[IpAddr]: ../../std/net/enum.IpAddr.html

[option]: ../../std/option/enum.Option.html

[docs]: ../../std/option/enum.Option.html
