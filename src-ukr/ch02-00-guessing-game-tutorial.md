# Програмування гри - відгадайки

Розпочнемо вивчення Rust зі спільної розробки проєкта! Цей розділ ознайомить вас із кількома поширеними концепціями Rust, показавши вам, як вони використовуються у реальній програмі. Ви дізнаєтеся про `let`, `match`, методи, асоційовані функції, використання зовнішніх крейтів і навіть більше! Наступні розділи розкриють ці концепції детальніше. У цьому розділі ви займатиметеся основами.

Ми розв'язуватимемо класичну задачу для програмістів-початківців: гру "відгадай число". Умови такі: програма генерує випадкове ціле число між 1 та 100. Потім пропонує гравцю відгадати. Після введення спроби вона скаже, чи число більше або менше за загадане. Якщо відгадано правильно, гра виведе вітання і припинить роботу.

## Початок нового проєкту

Щоб розпочати новий проєкт, перейдіть до теки *projects*, яку ви створили у Розділі 1, і створіть новий проєкт за допомогою Cargo, ось так:

```console
$ cargo new guessing_game
$ cd guessing_game
```

Перша команда, `cargo new`, приймає першим параметром ім'я проєкту (`guessing_game`). Друга команда переходить до теки нового проєкту.

Переглянемо щойно створений файл *Cargo.toml*:

<span class="filename">Afqk: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/Cargo.toml}}
```

Якщо інформація про автора, отримана Cargo з вашого середовища, неправильна, виправіть це і знову збережіть файл.

Як ви вже бачили у Розділі 1, `cargo new` створює програму "Hello, world!". Подивимося, що міститься у файлі *src/main.rs*:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/src/main.rs}}
```

Скомпілюймо цю програму “Hello, world!” і запустимо її за один крок за допомогою команди `cargo run`:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/output.txt}}
```

Команда `run` стає в нагоді, коли треба швидко розвивати проєкт, і ця гра є якраз таким проєктом: ви хочемо швидко тестувати кожну ітерацію перед тим, як переходити до наступної.

Знову відкрийте файл *src/main.rs*. Весь код ви будете писати у ньому.

## Обробляємо здогадку

Перша частина програми буде просити у користувача ввести здогадку, обробляти те, що він увів, і перевіряти, чи ввів він дані у потрібній формі. Для початку, дозволимо користувачеві ввести здогадку. Введіть код з Роздруку 2-1 до *src/main.rs*.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:all}}
```

<span class="caption">Роздрук 2-1: Код, що отримує здогадку у користувача і виводить її</span>

Цей код містить багато інформації, тому розбиратимемо його шматок за шматком. Щоб отримати, що ввів користувач, і вивести результат, нам треба ввести бібліотеку `io` (ввід/вивід, англ. input/output) у межі дії. Бібліотека `io` входить до стандартної бібліотеки (яка зветься `std`).

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:io}}
```

Усталено Rust вводить в межі дії тільки декілька типів у [*прелюдії*][prelude]
<!-- ignore -->(prelude). Якщо типу, який ви хочете використати, нема у прелюдії, вам доведеться явно вносити цей тип у межі дії за допомогою виразу `use`.  Використання бібліотеки `std::io` надає вам ряд корисних речей, пов'язаних із введенням-виведенням, включно з функціональністю для користувацького вводу.

Як ви бачили у Розділі 1, функція `main` - це точка входу в програму:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:main}}
```

Синтаксична конструкція `fn` проголошує нову функцію, `()` показує, що вона не має параметрів, і фігурна дужка `{` починає тіло функції.

Як ви вже знаєте з Розділу 1, `println!` - це макрос, що виводить стрічку на екран:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print}}
```

Цей код просто виводить повідомлення, що це за гра і запит введення у користувача.

### Зберігання значень у змінних

Тепер створімо місце для зберігання вводу користувача, ось так:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:string}}
```

Тепер програма стає цікавішою! В цьому коротенькому рядку відбувається багато всього. Зверніть увагу на інструкцію `let`, що використовується для створення *змінних*. Ось інший приклад:

```rust,ignore
let foo = bar;
```

Цей рядок створює нову змінну з назвою `foo` і зв'яже її зі значенням змінної `bar`. У Rust змінні типово є сталими (immutable). Детально ця концепція обговорюється в підрозділі ["Змінні і сталість"]()
<!-- ignore --> Розділу 3. Наступний приклад показує як  використовується `mut` перед іменем змінної, щоб зробити її несталою (mutable):

```rust,ignore
let foo = 5;     // стала
let mut bar = 5; // нестала
```

> Зверніть увагу: синаксична конструкція `//` починає коментар, що продовжується до кінця рядка. Rust ігнорує весь вміст коментаря, що описано детальніше у Розділі 3.

Повернімося до ношої ігрової програми - відгадайки. Тепер ви знаєте, що `let 
mut guess` створить несталу змінну на ім'я `guess`. З іншого боку знаку рівності (`=`) знаходиться значення, з яким зв'язується  `guess`, а саме - результат виклику `String::new`, функції, що повертає новий екземпляр стрічки String. [`String`][string]<!-- ignore --> - це тип стрічки, що надається стандартною бібліотекою; це кодовані в UTF-8 шматки тексту, які можна нарощувати.

Синаксична конструкція `::` в рядку `::new` позначає, що `new` - це *асоційована функція* типу `String`. Асоційована функція є реалізованою для типу, в цьому випадку `String`, а не для конкретного екземпляра `String`. В деяких мовах це зветься *статичним методом*.

Ця функція `new` створює нову, порожню `String`. Функція `new` зустрінеться вам у багатьох типах, оскільки це звичайна назва функції, що створює нове значення певного виду.

Підсумуємо: рядок `let mut guess = String::new();` створив несталу змінну, зараз прив'язану до нового, порожнього екземпляру `String`. Уф!

Згадаймо, що ми додали функціональність введення/виведення зі стандартної бібліотеки за допогою `use std::io;` у першому рядку програми. Тепер ми викличемо асоційовану функцію `stdin` з модулю `io`.

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:read}}
```

Якби на початку програми не було рядка `use std::io`, ми могли б записати цей виклик функції як `std::io::stdin`. Функциія `stdin` повертає екземпляр [`std::io::Stdin`][iostdin]<!-- ignore -->; цей тип репрезентує дескриптор (handle) стандартного потоку введення терміналу.

Наступна частина коду, `.read_line(&mut guess)`, викликає метод [`read_line`][read_line]<!-- ignore --> на дескрипторі стандартного потоку введення, щоб отримати те, що ввів користувач. Також ми передаємо `read_line` один параметр: `&mut guess`.

`read_line` бере все, що користувач вводить у стандартний потік введення, і додає це в стрічку (не перезаписуючи попередній вміст), тому приймає цю стрічку аргументом. Цей аргумент мусить бути несталим, щоб метод змінив вміст стрічки, додавши те, що ввів користувач.

`&` позначає, що цей аргумент - *посилання*, що дає вам можливість надати кільком частинам вашого коду доступ до одного фрагменту даних без кількаразового копіювання цих даних. Посилання - складна тема, але одна з основних переваг Rust полягає в безпеці і легкості використання посилань. Для завершення цієї програми вам не знадобляться особливо детальні знання про посилання; в Розділі 4 будуть надані докладніші пояснення. Поки що все, що вам треба знати - що посилання, як і зміні, типово є сталими. Тому необхідно писати `&mut guess`, а не просто `&guess`, щоб зробити її несталою. (Розділ 4 пояснить посилання ретельніше.)

### Керування потенційною невдачею за допомогою типу `Result`

Ми ще не закінчили розбиратися із цим рядком коду. Хоча це один рядок тексту, це лише перша частина єдиного логічного рядка коду. Наступна частина - це ось цей метод:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:expect}}
```

Коли ви викликаєте метод за допомогою синтаксичної конструкції `.foo()` часто має сенс розпочати новий рядок і додати відступи, щоб розділити довгі рядки. Ми могли б написати цей код так:

```rust,ignore
io::stdin().read_line(&mut guess).expect("Не вдалося прочитати рядок");
```

Але довгий рядок важко читати, тому краще поділити його на два рядки для виклику двох методів. Тепер розглянемо, що цей рядок робить.

Як вже було сказано, `read_line` кладе те, що ввів користувач, у стрічку, яку ми їй передали, але також повертає значення - в цьому випадку, [`io::Result`][ioresult]<!-- ignore -->. В стандартній бібліотеці Rust є кілька типів, що звуться Result: як узагальнений [`Result`][result]
<!-- ignore -->, так і спеціалізовані версії в підмодулях, як-от `io::Result`.

Типи `Result` - це [*переліки* (enumeration)][enums]<!-- ignore -->, які часто звуть просто *енум*. Перелік - це тип, який може набувати значення з визначеного набору, і ці значення звуться *варіантами* enum-а. Розділ 6 детальніше розкриє роботу enum-ів.

`Result` має варіанти `Ok` та `Err`. `Ok` показує, що операція була вдалою, і всередині варіанту `Ok` знаходиться успішно згенероване значення. `Err` позначає відмову, і містить інформацію, як і чому операція була невдалою.

Призначення типів `Result` - кодувати інформацію про обробку помилок. Значення типу `Result`, які інших типів, мають методи, визначені для них. Екземпляр `io::Result` має [метод `expect`][expect]<!-- ignore -->, який можна викликати. Якщо цей екземпляр `io::Result` має значення `Err`, то `expect` викличе аварійне завершення програми і виведе повідомлення, яке ви передали параметром `expect`. Якщо метод `read_line` поверне `Err`, це, швидше за все, буде результатом помилки в операційній системі. Якщо цей екземлпяр `io::Result` має значення `Ok`, `expect` візьме значення, яке знаходиться в `Ok`, і поверне тільки це значення, щоб їм можна було скористатися. В цьому випадку це значення - кількість байтів, введених користувачем до стандартного потоку.

Якщо ми не викличемо `expect`, програма скомпілюється, проте ми отримаємо попередження:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-02-without-expect/output.txt}}
```

Rust попереджає, що ми не використали значення `Result`, повернуте з `read_line`, що означає, що програма не обробила можливу помилку.

Правильний спосіб пригнітити попередження - власне, обробити помилку, але оскільки ми просто хочемо, щоб програма аварійно завершилася, якщо виникне проблема, можна скористатися `expect`. Ви дізнаєтеся про те, як відновити роботу програми при помилці, у Розділі 9.

### Вивід значень за допомогою заповнювачів `println!`

Якщо не враховувати закриваючої фігурної дужки, поки щол ишився лише один рядок, який ми ще не обговорили, а саме:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print_guess}}
```

Цей рядок виводить стрічку, в якій ми зберегли те, що ввів користувач. Фігурні дужки `{}` - це заповнювач: можна уявити це клешнями маленького краба, що тримає значення на місці. Ви можете вивести більше одного значення за допомогою `{}`: перший набір `{}` замінюється першим  значенням після форматної стрічки, другий набір - другим значенням і так далі. Вивід багатьох значень за один виклик `println!` виглядатиме так:

```rust
let x = 5;
let y = 10;

println!("x = {} і y = {}", x, y);
```

Цей код виведе `x = 5 і y = 10`.

### Тестування першої частини

Протестуймо першу частину гри "відгадай число". Запустіть її за допомогою `cargo run`:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Відгадай число!
Введіть здогадку.     
6
Ваша здогадка: 6
```

На цей момент перша частина гри завершена: ви отримуємо дані з клавіатури і виводимо їх.

## Генерація таємного числа

Тепер нам треба згенерувати таємне число, яке користувач пробуватиме відгадати. Таємне число має бути різним кожного разу, щоб у гру було цікаво грати більше одного разу. Використаймо випадкове число від 1 до 100, щоб гра була не надто складною. Rust поки що не має функціональності для генерації випадкових чисел у стандартній бібліотеці; натомість команда Rust надає [крейт `rand`][randcrate].

### Використання крейту для отримання додаткової функціональності

Запам'ятайте, що крейт - це пакет коду Rust. Проєкт, який ми робимо - *двійковий крейт* і є виконанним. Crate `rand` - *бібліотечний крейт*, і містить код, призначений для використання в інших програмах.

Використання зовнішніх крейтів - найсильніший бік Cargo. Перед тим, як писати код, що використовує `rand`, ми маємо змінити файл *Cargo.toml*, додавши туди крейт `rand` як залежність. Відкрийте цей файл і додайте такий рядок унизу, під заголовком секції `[dependencies]`, яку для вас створив Cargo:

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->

<span class="filename">Файл: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:9:}}
```

У файлі *Cargo.toml* все, що йде після заголовку секції, належить до цієї секції - до початку нової секції із нового заголовку. У секції `[dependencies]` ви повідомляєте Cargo, від яких зовнішніх крейтів залежить і які версії цих крейтів вам потрібні. У цьому випадку, ми зазначаємо крейт `rand` зі семантичним версіонуванням `0.3.14`. Cargo розуміє \[семантичне версіонування\]\[ semver\]<!-- ignore -->  (також зване *SemVer*), що є стандартом для запису номеру версії. Запис `0.3.14` насправді є скороченням для `^0.3.14`, що означає "будь-яка версія, що має публічний API, сумісний із версією 0.3.14".

Тепер, не змінюючи коду, побудуємо проєкт, як показано в Роздруку 2-2:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo clean
cargo build -->

```console
$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
  Downloaded libc v0.2.62
  Downloaded rand_core v0.2.2
  Downloaded rand_core v0.3.1
  Downloaded rand_core v0.4.2
   Compiling rand_core v0.4.2
   Compiling libc v0.2.62
   Compiling rand_core v0.3.1
   Compiling rand_core v0.2.2
   Compiling rand v0.5.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
```


<span class="caption">Роздрук 2-2: Вивід команди `cargo build` після додавання крейту rand як залежності.</span>

Ви можете побачити інші номери версій (але вони будуть сумісні з кодом завдяки SemVer!), якісь інші рядки (залежно від операційної системи) і рядки можуть бути в іншому порядку.

Тепер, коли ми маємо зовнішню залежність, Cargo витягає останні версії всього, що нам треба, з *реєстру*, тобто копії даних з [Crates.io][cratesio]. На crates.io в екосистемі Rust люди викладають свої проєкти Rust з відкритим кодом, щоб ними могли скористатися інші.

Після оновлення реєстру, Cargo перевіряє розділ `[dependencies]` і завантажує ті крейти, яких у вас бракує. В цьому випадку, хоча ми вказали тільки залежність від `rand`, Cargo також завантажив копію `libc` і `rand_core`, тому що `rand`  потребує їх для рооботи. Після завантаження, Rust компілює їх і потім компілює проєкт із доступними залежностями.

Якщо ви знову запустите `cargo build`, не зрозбивши жодних змін, ви не отримаєте жодної відповіді окрім рядка `Finished`. Cargo знає, що він вже завантажив і скомпілював залежності, а ви не змінили нічого у файлі *Cargo.toml*. Cargo такрж знає що ви не змінили нічого у коді, тому він не буде його перекомпільовувати. Оскільки роботи у Cargo немає, він просто завершується.

Якщо ви відкриєте файл *src/main.rs*, зробите тривіальну зміну, збережете і знову побудуєте, то побачите тільки два рядки виводу:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->

```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```

Ці рядки показують, що Cargo обробив тільки вашу дрібну зміну до файлу *src/main.rs*. Залежності не змінилися, і Cargo знає, що може заново використати те, що він вже завантажив і скомпілював. Він перебудовує тільки вашу частину коду.

#### Файл *Cargo.lock* гарантує відтворюваність побудови

Cargo має механізм, що гарантує однаковість побудови проєкту кожного разу, коли ви чи хтось інший будує ваш код: Cargo використає тільки ті версії залежностей, які ви зазначили, доки ви не вкажете інші. Наприклад, якщо наступного тижня вийде `rand` версії `0.3.15`, що міститиме важливе виправлення вади, але також регресію, що зіпсує ваш код?

Відповідь на цю задачу - файл *Cargo.lock*, що створюється при першому запуску `cargo build` і розміщується у теці *guessing_game*. Коли ви збираєте проєкт вперше, Cargo визначає всі версії залежностей, що відповідають критерію, і записує їх у файл *Cargo.lock*. Коли ви пізніше збиратимете проєкт, Cargo побачить, що файл *Cargo.lock* існує, і використає версії, зазначені там, а не буде наново визначати версії. Це дозволяє вам автоматично мати відтворювану збірку. Іншими словами, ваш проєкт залишиться на версії `0.3.14`, доки ви самі не захочете оновити її, завдяки файлу *Cargo.lock*.

#### Оновлення крейта для отримання нової версії

Коли ви *хочете* оновити крейт, Cargo надає іншу команду, `update`, яка ігнорує файл *Cargo.lock* і визначає всі останні версії, що відповідають специфікаціям в *Cargo.toml*. Якщо це вдалося, Cargo напише ці версії до файлу *Cargo.lock*.

Але типово Cargo шукатиме тільки  версії, більші за `0.5.5` і менші `0.6.0`. Якщо crate `rand` вийшов у двох нових версіях, `0.5.6` та `0.6.0`, ви побачите таке, запустивши `cargo update`:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.5.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->

```console
$ cargo update
    Updating crates.io index
    Updating rand v0.5.5 -> v0.5.6
```

Також можна звернути увагу на зміну у файлі *Cargo.lock* - версія крейта `rand`, яку ви використовуєте, тепер `0.5.6`.

Якщо вам потрібен `rand` версії `0.6.0` чи будь-якої версії у гілці `0.6.x`, вам доведеться оновити файл *Cargo.toml*, щоб він мав такий рядок:

```toml
[dependencies]

rand = "0.6.0"
```

Наступного разу, коли ви запустите `cargo build`, Cargo оновить реєстр доступних крейтів і заново перечитає вимоги до `rand` відповідно до вказаної вами нової версії.

Можна багато сказати про [Cargo][doccargo]<!-- ignore --> і [його екосистему][doccratesio]<!-- ignore -->, яка обговорюється у Розділі 14, але поки що цього знати достатньо. Cargo робить використання бібліотек дуже простим, що дозволяє растацеанцям писати менші проєкти, зібрані з кількох пакетів.

### Генерація випадкового числа

Тепер, коли ми додали `rand` до *Cargo.toml*, почнемо використовувати `rand`. Наступний крок - оновити *src/main.rs*, як показано в Роздруку 2-3:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:all}}
```


<span class="caption">Роздрук 2-3: Додаємо код, необхідний для генерації випадкового числа </span>

Спершу ми доємо рядок `use`: `use rand::Rng`. Трейт `Rng` визначає методи, які реалізує генератор випадкових чисел, і цей трейт має бути в області видимості, щоб ми могли скористатися цими методами. Розділ 10 розповість про трейти детальніще.

Далі ми додаємо всередині ще два рядки. Функція rand::thread_rng дасть нам генератор виадкових чисел, яким ми користуватимемся: він прив'язаний до потоку виконання, а його початкове значення задане операційною системою. Потім ми викликаємо метод генератора випадкових чисел `gen_range`. Цей метод визначається трейтом `Rng`, який ми внесли до області видимості інструкцією `
use range::Rng`. Метод `gen_range` приймає параметрами два числа  і генерує випадкове число між ними, включно з нижньою межею, але виключаючи верхню, тому треба вказувати `1` та `101`, щоб отримати число між 1 та 100 включно.

> Примітка: Знання, які риси використати і які функції та методи викликати з крейта не є чимось таким, що треба знати напам'ять. Інструкції з икористання крейта є в документації цього крейта. Ще одна корисна можливість Cargo полягає в тому, що команда `cargo doc --open` побудує на вашому комп'ютері документацію, надану всіма залежностями, і відкриє її у вашому переглядачі. Якщо вам цікава інша функціональність crate-а `rand`, запустіть `cargo doc > --open` і клацніть `rand` на боковій панелі ліворуч.

Другий рядок, який ми додали до коду, виводить таємне число. Це корисно, коли ми розробляємо програму, щоб можна було перевірити її роботу, але ми видалимо її у фінальній версії. Буде не дуже цікаво, якщо програма виводитиме відповідь одразу по запуску!

Спробуємо запустити програму кілька разів:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

Ви маєте побачити різні випадкові числа, і вони мають бути між 1 та 100. Чудово!

## Порівняння здогадки з таємним числом

Тепер, коли ми маємо введене користувачем і випадкове числа, ми можемо їх порівняти. Цей крок показано в Роздруку 2-4:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-04/src/main.rs:here}}
```


<span class="caption">Роздрук 2-4: Різні дії в залежності від порівняння двох чисел</span>

Перше нововведення - ще один `use`, який вводить тип `std::cmp::Ordering` зі стандартної бібліотеки у область видимості. `Ordering` ("впорядкування") - це ще один енум, як і `Result`, але варіанти `Ordering` такі: `Less` ("менше"), `Greater` ("більше"), and `Equal` ("дорівнює"). Це три можливі результати при порівнянні двох чисел.

Потім ми додали в кінець коду п'ять нових рядків, в яких використали тип `Ordering`. Метод `cmp` порівнює два значення і може бути викликаний для всього, що можна порівнювати. Він приймає параметром посилання на те, що ви хочете порівнювати із ним: тут він порівнює `guess` із `secret_number`. `cmp` повертає варіант з enum-у `Ordering`, який ми внесли у межі дії за допомогою інструкції `use`. Ми скористалися виразом [`match`][match]<!-- ignore -->, щоб визначити, що робити далі залежно від варіанту `Ordering`, що його повернув виклик `cmp` зі значеннями `guess` та `secret_number`.

Вираз `match` складається з *рукавів* (у інших мовах такі конструкції зазвичай звуться гілками). Рукав складається зі *зразка* (*pattern*) та коду, який буде виконано, якщо значення, передане виразу `match`, відповідає зразку цього рукава. Rust бере значення, передане `match`, і по черзі переверяє зразки рукавів. Конструкція `match` і зразки - потужні засоби мови Rust, які дозволяють вам виражати різноманітні ситуації, які можуть трапитися вам при програмуванні, і допомагають переконатися, що ви обробили їх усіх. Детально ці можливості будуть розглянуті в Розділах 6 і 18, відповідно.

Hозберімо крок за кроком, як спрацює в цьому коді вираз `match`. Нехай користувач увів 50, а випадково згенероване цього разу таємне число - 38. Коли код порівнює 50 і 38, метод `cmp` поверне `Ordering::Greater`, бо 50 більше за
38. Це значення отримує вираз `match`. Він перевіряє зразок першого рукава, `
Ordering::Less`, але значення `Ordering::Greater` не відповідає `Ordering::Less`. Тому код цього рукава ігнорується і ми переходимо до наступного рукава. Зразок другого рукава, `Ordering::Greater`, *відповідає* `Ordering::Greater`! Код цього рукава буде  виконано і виведе на екран `Забагато!`. Вираз `match` завершується, бо в цьому конкретному випадку більше нема сенсу перевіряти останній рукав.

Але код у Роздруку 2-4 все ще не компілюється. Спробуємо його скопмілювати:

```console
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-04/output.txt}}
```

Суть цієї помилки в тому, що тут є *невідопвідні типи*. Rust має сильну, статичну систему типів. Разом із тим, він має систему виведення типів. Коли ви писали `let guess = String::new()`, Rust зміг вивести, що `guess` має бути типу `String` і не просив нас написати тип. `secret_number`, з іншого боку, числового типу. Кілька числових типів можуть мати значення між 1 та 100: `i32`, знакове 32-бітне число; `u32`, беззнакове 32-бітне число; `i64`, знакове 64-бітне число і кілька інших. Типовий вибір Rust `i32`, і це й буде типом `secret_number`, якщо ми не додамо інформацію про тип деінде, щоб змусити Rust вивести інший числовий тип. Причина ж цієї помилки полягає в тому, що Rust не може порівнювати стрічку і числовий тип.

Зрештою, ми хочемо перетворити стрічку `String`, яку програма прочитала з клавіатури, в числовий тип, щоб можна було порівняти його зі таємним числом. Це можна зробити, додавши ще один рядок до функції `main`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/src/main.rs:here}}
```

Ось цей рядок:

```rust,ignore
let guess: u32 = guess.trim().parse().expect("Будь ласка, введіть число!");
```

Ми створили змінну з назвою `guess`. Але чекайте, в програмі вже ніби існує змінна з назвою `guess`? Так, але Rust дозволяє *затінювати* попереднє значення `guess` новим. Ця особливість часто використовується у схожих ситуаціях, коли нам треба перевторити значення з одного типу в інший. Затінення дозволяє нам наново використати ім'я змінної `guess`, щоб не довелося створювати дві окремі змінні на кшталт `guess_str` і `guess`. Розділ 3 детальніше розповідає про затінення.

Ми зв'язали `guess` з виразом `guess.trim().parse()`. `guess` в цьому виразі - це перша змінна `guess`, яка має тип `String`, у якій міститься те, що ввів користувач. Метод `trim`, застосований до екземпляру `String`, видалить всі пробільні символи на початку і в кінці. `u32` може бути створений лише зі стрічки, яка містить тільки цифри, але користувач має натиснути на <span class= "keystroke">enter</span>, щоб спрацював метод `read_line`. При цьому в кінець стрічки додається символ нового рядка. Наприклад, якщо користувач набере <span
class="keystroke">5</span> і натисне <span class="keystroke">enter</span>, `guess` буде виглядати як `5\n`, де `\n` представляє символ нового рядка, що вводиться натисканням <span class="keystroke">enter</span>.  Метод `trim` видалить `\n`, і залишиться просто `5`.

[Метод `parse` для стрічок][parse]<!-- ignore --> розбирає стрічку, виділяючи число певного виду. Оскільки цей метод може виділяти різні числові типи, там необхідно вказати Rust, який саме числовий тип ми хочемо отримати - за допомогою`let guess: u32`. Двокрапка `:` після `guess` каже Rust, що ми позначаємо тип змінної. В Rust є кільки вбудованих числових типів; ми вибрали `u32` - беззнакове 32-бітне ціле. Це непоганий вибір для невеликих додатних чисел. Про інші типи ви дізнаєтеся у Розділі 3. На додачу, саме позначка `u32` у цьому прикладі і порівняння із `secret_number` дає Rust можливість вивести, що `secret_number` теж має бути `u32`. І тепер порівнюватимуться два значення одного типу!

Виклик `parse` може легко призвести до помилки. Якщо, наприклад, стрічка містить`A👍%`, її неможливо буде перетворити на число. Оскільки метод може завержитися невдачею, він повертає `Result`, майже так само, як і  метод `read_line`, про який ми вже говорили раніше в підрозділі ["Керування потенційною невдачую за допомогою типу `Result`"] (#handling-potential-failure-with-the-result-type)<!-- ignore -->). Ми обробимо цей `Result` так само - за допомогою методу `expect`. Якщо `parse` поверне варіант `Err`, значить, він не зміг створити число зі стрічки, `expect` припинить гру і виведе повідомлення, яке ми йому надали. Якщо `parse` вдало створив число зі стрічки, він поверне варіант `Ok`, а `expect` поверне потрібне нам число зі значення `Ok`.

А тепер запустімо програму!

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

Чудово! Хоча ми й додали пробіли перед здогадкою, програма все одно зрозуміла, що користувач увів 76. Запустіть програму кілька разів, щоб перевірити різну поведінку на різних введених даних: введіть таємне число, більше за нього і менше.

Гра тепер майже працює, але користувачеві надається тільки одна можливість вгадати. Змінимо це, додавши цикл!

## Введення кількох здогадок за допомогою циклу

Ключове слово `loop` створює нескінчений цикл. Додамо його, щоб дати користувачам більше можливостей відгадати число:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-04-looping/src/main.rs:here}}
```

Як ви можете бачити, ми перенесли в цикл усе від запрошення ввести здогадку і до кінця. Додайте в ці рядки відступи у чотири пробілами і знову запустіть програму. Зверніть увагу, що виникла нова проблема, бо програма робить саме те, що ми їй сказали: запрошує ввести нову здогадку до нескінченості! Схоже, користувач не може вийти!

Користувач завжди може перервати програму, натиснувши клавіатурне скорочення <span class="keystroke">ctrl-c</span>. Але є інший спосіб втекти від цього ненажерного чудовиська - згаданий при обговоренні `parse` в підрозділі “Порівняння здогадки з таємним числом”: якщо користувач введе щось, крім числа, програма аварійно завершиться. Користувач може цим скористатися, щоб вийти з програми:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

Введення `вийти` дійсно призводить до виходу з гри, але так само спрацює будь-що, що не є числом. Тим не менше, це щонайменше не найкращий спосіб. Ми хочемо, щоб гра сама зупинялася, коли ми відгадали число.

### Вихід після вдалої здогадки

Запрограмуймо гру виходити, якщо користувач виграв, додавши `break`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-05-quitting/src/main.rs:here}}
```

Додавання рядку `break` після `println!("Ви перемогли!");` примусить програму вийти з циклу, якщо користувач відгадав таємне число. Вихід із циклу призведе до виходу з програми, бо цикл - це остання частина функції `main`.

### Обробка неправильного введення

Для покращення роботи гри замість аварійного виходу при введені не-числа, зробимо так, що гра ігнорувала те, що ми ввели, щоб користувач міг продовжувати відгадувати. Ми можемо зробити це, попрацювавши з рядком, де `guess` перетворюється з `String` на `u32`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:here}}
```


<span class="caption">Роздрук 2-5: ігнорування введеного не-числа і запит ввести іншу відгадку замість аварійного завершення програми</span>

Заміна виклику `expect` на вираз `match` - загальний спосіб переходу від аварійного завершення програми до реальної обробки помилки. Згадаємо, що метод `parse` повертає тип `Result`, а `Result` - це enum, що має варіанти `Ok` та `Err`. Ми використовуємо тут вираз `match`, так само, як робили з `Ordering`, що його повертає метод `cmp`.

Якщо `parse` зможе вдало перетворити стрічку на число, він поверне значення `Ok`, що міститиме число - результат. Це значення `Ok` буде відповідати зразку першого рукава, і весь вираз `match` поверне значення `num`, яке `parse` обчислив і поклав всередину значення `Ok`. Це число потрапить саме туди, куди нам треба - в нову змінну `guess`, яку ми створюємо.

Якщо `parse` не зможе перетворити стрічку на число, він поверне значення `Err`, що міститиме більше інформації про помилку. Значення `Err` не відпвідає зразку `Ok(num)` у першому рукаві `match`, але відповідає зразку `Err(_)` у другому. `_` - це узагальнене значення; в цьому випадку, ви кажемо, що хочемо відповідати будь-якому `Err`, незалежно від інформації, що міститься у ньому. Програма виконає код другого рукава, `continue`, що означає - перейти на наступну ітерацію циклу `loop` і, відтак, попросити про наступну спробу. Таким чином, програма ігнорує всі помилки, які можуть зустрітися `parse`!

Нарешті все у нашій програмі має працювати як треба. Спробуємо запустити `cargo run`:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

Відмінно! Лишилася тільки одна дрібна правка, і робота буде завершена: програма все ще виводить таємне число. Це було необхідно для тестування, але псує гру. Видаляємо `println!`, який виводить таємне число, і маємо на Роздруку 2-5 остаточний код:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-06/src/main.rs}}
```

<span class="caption">Роздрук 2-5: Повний код гри "відгадай число!"</span>

## Підсумок

Отже, ви зуміли вдало побудувати гри "відгадай число"! Вітаємо!

Цей проєкт був вступом до багатьох концепцій мови Rust через практику: `let`, `match`, методи, асоційонвані функції, використання зовнішніх крейтів і т.ін. У кількох наступних розділах ми детальніше розберемо ці концепції. Розділ 3 розповідає про концепції, які є у більшості мов програмування, такі як змінні, типи даних, функції і показує, як ними користуватися в Rust. Розділ 4 розповідає про власність, концепцію мови Rust, що є найбільш відмінною від інших мов. Розділ 5 обговорює структури і методи, а Розділ 6 детально розкриває енуми.
ch03-01-variables-and-mutability.html#variables-and-mutability

[prelude]: ../std/prelude/index.html

[string]: ../std/string/struct.String.html

[iostdin]: ../std/io/struct.Stdin.html

[read_line]: ../std/io/struct.Stdin.html#method.read_line

[ioresult]: ../std/io/type.Result.html
[result]: ../std/result/enum.Result.html

[enums]: ch06-00-enums.html

[expect]: ../std/result/enum.Result.html#method.expect

[randcrate]: https://crates.io/crates/rand

[cratesio]: https://crates.io

[doccargo]: http://doc.crates.io
[doccratesio]: http://doc.crates.io/crates-io.html

[match]: ch06-02-match.html

[parse]: ../std/primitive.str.html#method.parse
