## Конструкція управління `match`

Rust має вкрай потужну конструкцію управління, що зветься `match`, яка дозволяє нам порівнювати значення із кількома шаблонами та потім виконати код, виходячи з того, який шаблон відповідає цьому значенню. Шаблони можуть складатися з літеральних значень, імен змінних, байдужих символів і багатьох інших речей; Розділ 18 розкриває усі види шаблонів і що вони роблять. Потужність `match` походить виразності шаблонів, а компілятор перевіряє, щоб усі можливі варіанти були оброблені.

Вираз `match` можна уявити собі як сортувальну машину для монет: монети ковзають жолобом із отворами різних розмірів, і кожна монета падає крізь перший отвір, в який вона проходить. Так само значення проходить крізь кожен шаблон в `match`, і на першому шаблоні, якому воно відповідає, значення "провалюється" в пов'язаний блок коду, де може бути використане.

Оскільки ми згадали монети, використаємо їх як приклад використання `match`! Ми можемо написати функцію, що приймає невідому монету Сполучених Штатів і, так само як і лічільна машина, визначає, яка це монета і повертає її значення в центах, як показано в Роздруку 6-3:

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```


<span class="caption">Роздрук 6-3: Enum і вираз `match` із варіантами enum-а як шаблонами.</span>

Розберемо `match` у функції `value_in_cents`. По-перше, ми пишемо ключове слово `match`, за яким іде вираз, у цьому випадку - значення `coin`. Це дуже схоже на вираз, що ми використовувати у `if`, але є велика відмінність: у `if` вираз має повертати булеве значення. Тут він може бути будь-якого типу. Тип `coin` у цьому прикладі - enum `Coin`, визначений у Роздруку 6-3.

Далій йдуть рукави `match`. Рукав має дві частини: шаблон і код. Перший рукав має шаблон, що є значенням `Coin::Penny`, після якого оператор `=>` відокремлює шаблон і код, що буде виконано. Код, у цьому випадку - просто значення `1`. Кожен рукав відокремлений від наступного комою.

Коли виконується вираз `match`, значення по черзі порівнюється із шаблоном кожного рукава. Якщо шаблон відповідає значенню, виконується пов'язаний із цим шаблоном код. Якщо шаблон не відопвідає значенню, виконання передається наступному рукаву, як монетка в сортувальній машині. Рукавів може бути стільки, скільки нам потрібно: у Роздруку 6-3 `match` має чотири рукави.

Код, пов'язаний з коженим рукавом - вираз, що повертає значення, і кінцеве значення виразу рукава, що підійшов, стає значенням, що повертається усім виразом `match`.

Фігурні дужки зазвичай не використовуються, якщо код рукава match невеликий, як у Роздруку 6-3, де кожен рукав просто повертає значення. Якщо ви хочете виконати багато рядків коду у рукаві match, можете скористатися фігурними дужками. Наприклад, наступний код виводитиме “Щаслива монетка!” кожного разу, коли метод викличуть для `Coin::Penny`, але також поверне останнє значення блоку, тобто `1`:

```rust
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => {
            println!("Щаслива монетка!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

### Шаблони, що зв'язуються зі значеннями

Інша корисна властивість рукавів match полягає в тому, що вони можуть зв'язуватися з частинами значення, що відповідає шаблону. Таким чином ми можемо дістати значення з варіантів enum-ів.

Наприклад, змінімо один з варіантів enum-а, щоб він мав дані усередині. З 1999 по 2008 роки Сполучені Штати карбували чвертаки з різними дизайнами для кожного з 50 штатів на одному боці. Інші монети не мають окремих дизайнів для штатів, тому лише чвертаки мають таке додаткове значення. Ми можемо додати цю інформацію до нащого `enum`-а, змінивши варіант `Quarter`, аби він включав значення `UsState` у собі, що й зроблено в Роздруку 6-4:

```rust
#[derive(Debug)] // Щоб можна було швидко подивитися, що за штат
enum UsState {
    Alabama,
    Alaska,
    // ... і т.д.
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
```


<span class="caption">Listing 6-4: Enum `Coin`, де варіант `Quarter` має всередині значення `UsState`</span>

Уявімо, що наш друг намагається зібрати всі 50 чвертаків різних штатів. Сортуючи дріб'язок по типах монет, ми також будемо називати назви штатів, пов'язаних з кожним чвертаком, щоб, якщо такого друг такого не має, він зміг би додати його до своєї колекції.

У виразі match у цьому коді ми додаємо змінну, що зветься `state` до шаблону, що відповідає значенням варіанту `Coin::Quarter`. Коли шаблон `Coin::Quarter` буде відповідним до виразу, змінна `state` зв'яжеться зі значенням стану цього чвертака. Тоді ми можемо використати `state` у коді цього рукава, ось так:

```rust
# #[derive(Debug)]
# enum UsState {
#    Alabama,
#    Alaska,
# }
#
# enum Coin {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(UsState),
# }
#
fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("Чвертак штату {:?}!", state);
            25
        },
    }
}
```

Якщо ми викличемо `value_in_cents(Coin::Quarter(UsState::Alaska))`, значення `coin` буде `Coin::Quarter(UsState::Alaska)`. При порівнянні цього значення з усіма рукавами не підійде жоден, окрім `Coin::Quarter(state)`. У цьому місці, `state` буде зв'язане зі значенням `UsState::Alaska`. Ми можемо тоді скористатися цим зв'язуванням у виразі `println!`, отримавши таким чином внутрішнє значення штату з enum-у `Coin` для варіанту `Quarter`.

### Match і `Option<T>`

У попередньому підрозділі ми хотіли дістати внутрішнє значення типу `T` з варіанту `Some`, коли працювали з `Option<T>`; з `Option<T>` ми теж можемо скористатися конструкцією `match`, так само, як з enum-ом `Coin`! Замість монет, порівнюватимемо варіанти `Option<T>`, вираз `match` при цьому працює тим самим чином.

Хай, скажімо, ми хочемо написати функцію, що приймає `Option<i32>`, і якщо воно має значення, додає один до цього значення. А якщо там немає значення всередині, функція має повертати значення `None` і не намагатися виконати жодних дій.

Цю функцію дуже легко написати завдяки `match`, вона виглядатиме так, як у Роздруку 6-5:

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```


<span class="caption">Роздрук 6-5: функція, що застосовує вираз `match` на `Option<i32>`</span>

#### Рукав `Some(T)`

Розглянемо детальніше перше виконання `plus_one`. Коли ми викликаємо `plus_one(five)`, змінна `x` у тілі `plus_one` матиме значення `Some(5)`. Ми можемо порівняти це значення з кожним рукавом match.

```rust,ignore
None => None,
```

Значення `Some(5)` не відповідає шаблону `None`, і ми переходимо до наступного рукава.

```rust,ignore
Some(i) => Some(i + 1),
```

Чи відповідає `Some(5)` шаблону `Some(i)`? Так, звісно! Це саме наш варіант. Змінна `i` зв'язується зі наченням, що міститься в `Some`, тобто `i` набуває значення 5. Далі виконується Код у рукаві match, тобто додається один до значення `i` і ствоюється нове значення `Some` із результатом 6 всередині.

#### Рукав `None`

Тепер розглянемо другий виклик `plus_one` у Роздруку 6-5, де `x` дорівнює `None`. Ми входимо в match і порівнюємо перший рукав.

```rust,ignore
None => None,
```

Підходить! Немає значення, до якого треба додавати, і програма зупиняється і повертає значення `None`, що стоїть праворуч від `=>`. Оскільки перший рукав відповідає значенню, решта рукавів не перевіряються.

Комбінування `match` і enum-ів корисне в багатьох ситуаціях. Ви часто бачитимете цей шаблону у коді Rust: `match` із enum-ом, зв'язування змінної з даними усередині, і виконання коду відповідно до цього. Це спершу трохи мудровано, але щойно ви звикните до цього, то бажатимете мати таку конструкцію в усіх мовах. Ця конструкція - незмінний улюбленець користувачів Rust.

### Match вимагає вичерпності

Є ще один бік `match`, що ми маємо обговорити. Розглянемо таку версію нашої функції `plus_one`:

```rust,ignore
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

Ми не обробляємо варіанту `None`, тому цей код призводить до вади. На щастя, Rust знає, як виявляти такі вади. Якщо ми спробуємо скомпілювати цей код, то отримаємо таке повідомлення про помилку:

```text
error[E0004]: non-exhaustive patterns: `None` not covered
 -->
  |
6 |         match x {
  |               ^ pattern `None` not covered
```

Rust знає, що ми не покрили усі можливі випадки, і навіть знає, який саме шаблон ми забули! Match в Rust *вичерпні*: ми маємо вичерпати всі можливі ситації, щоб код був коректним. Особливо у випадку `Option<T>` Rust, запобігаючи тому, щоб ми забули явно обробити випадок `None`, захищає нас від припущення, що ми маємо значення, коли ми можемо мати null, таким чином припускаючись помилки на мільярд доларів, про яку ми говорили вище.

### Заповнювач `_`

Rust також має шаблон, яким ми можемо скористатися в сиутаціях, коли ми не бажаємо перерраховувати усі можливі занчення. Наприклад, `u8` може мати коректні значення від 0 до 255. Якщо там важливі тільки значення 1, 3, 5 і 7, нам не кортітиме перераховувати 0, 2, 4, 6, 8, 9 і так далі до 255. На щастя, нам і не треба: ми можемо використи натомість спеціальний шаблон `_`:

```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("один"),
    3 => println!("три"),
    5 => println!("п'ять"),
    7 => println!("сім"),
    _ => (),
}
```

Шаблон `_` відповідає будь-якому значенню. Розміщений після усіх інших рукавів, `_` буде відповідати усім можливим варіантам, які ми ще не розглянули раніше. `()` - це просто значення unit, тому нічого не стається у випадку `_`. У результаті ми можемо сказати, що ми не хочемо нічого робити для всіх можливих значень, не перерахованих до заповнювача `_`.

[Насправді, `_` - це просто ім'я змінної, яке не викликає попередження компілятора, що ми не використали значення цієї змінної. Ми могли б так само написати і `x => ()` в останньому рукаві, цей шаблон очевидно буде відповідати будь-якому значенню; але невикористане значення викликає попередження про можливу помилку, яку притлумлює спеціальна назва змінної. Тобто мова йде не про особливу конструкцію мови, а про особливе ім'я змінної - прим. перекладача]

Однак вираз `match` може бути дещо забагатослівним у випадках, коли нас цікавить лише *один* випадок. Для цих сиутацій Rust надає конструкцію `if let`.
