## Зрізи

> Від перекладача: приклад у цьому розділі написаний лише для кращого розуміння концепції зрізів. Зокрема, спроба замінити рядок на кириличний може призвести до неочікуваних наслідків. Причина таких проблем роз'яснуюється у Розділі 8.2. Можливо, це буде виправлено в останніх версіях оригіналу.

Інший тип данних, що не тримає володіння - *зріз* (*slice*). Зрізи дозволяють посилатися на неперервні послідовності елементів в колекції замість усієї колекції.

Існує така проста програмістська задача: написати функцію, що приймає стрічку і повертає перше слово, яке знаходиться в цій стрічці. Якщо функція не знайде пробіл у стрічці, це означає що вся стрічка є одним словом і, відтак, функція має повернути всю стрічку.

Спробуємо написати сигнатуру цієї функції?

```rust,ignore
fn first_word(s: &String) -> ?
```

Ця функція, `first_word`, приймає параметром `&String`. Нам не потрібна власність, тому це нормально. Але що ми маємо повернути? У нас немає способу, що виразити *частину* стрічки. Тим не менш, ми можемо повернути індекс кінця слова. Спробуємо зробити це у Роздруку 4-10:

<figure>
<span class="filename">Файл: src/main.rs</span>

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

<figcaption>

Роздрук 4-10: Функція `first_word`, що повертає індекс символа пробіла 
у параметрі типу `String`.

</figcaption>
</figure>

Давайте трохи розберемо цей код. Оскільки нам треба перебрати стрічку у параметрі `s` елемент за елементом і перевірити, чи не пробіл це, ми перетворюємо стрічку на масив байтів за допомогою методу `as_bytes`:

```rust,ignore
let bytes = s.as_bytes();
```

Далі ми створюємо ітератор по масиву байтів за допомогою методі `iter`:

```rust,ignore
for (i, &item) in bytes.iter().enumerate() {
```

Ітератори будуть детальніше обговорені в Розділі 16. Поки що достатньо знати, що `iter` - метод, що повертає кожен елемент в колекції, а метод `enumerate` обгортає результат у кортеж, перший елемент якого - індекс, а другий - посилання на елемент. Це трохи зручніше, ніж обчислювати індекс самостійно.

Оскільки метод `enumerate` повертає кортеж, ми використаємо шаблон для деструктуризації цього кортежу. В циклі `for` ми визначаємо шаблон, що складається з індексу `i` і елементу `&item` в кортежі. `&` в шаблоні позначає, що це посилання.

Ми шукаємо байт, який представляє символ пробілу, за допомогою байтового літералу. Коли знаходимо його, повертаємо його індекс. Якщо цього не сталося, повертаємо довжину стрічки за допомогою методу `s.len()`:

```rust,ignore
    if item == b' ' {
        return i;
    }
}
s.len()
```

Тепер ми маємо спосіб знайти індекс кінця першого слова у стрічці, але є проблема. Ми повертаємо одне значення `usize`, але це значення має сенс лише в контексті нашої стрічки. Іншими словами, оскільки це значення не пов'язане із зі стрічкою, немає гарантії, що воно буде коректним у подальшому. Розглянемо програму у Роздруку 4-11, що використовує функцію `first_word` з Роздруку 4-10:

<figure>
<span class="filename">Файл: src/main.rs</span>

```rust
# fn first_word(s: &String) -> usize {
#     let chars = s.chars();
#
#     for (i, item) in chars.enumerate() {
#         if item == ' ' {
#             return i;
#         }
#     }
#
#     s.len()
# }
#
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word матиме значення 5

    s.clear(); // Очищуємо s, так що його значення стає "".

    // word все ще містить значення 5, але рядка, в якому можна використати
    // це значення, вже не існує. word має некоректне значення!
}
```

<figcaption>

Роздрук 4-11: Збереження результату виклику функції `first_word` і наступна 
зміна вмісту стрічки

</figcaption>
</figure>

Ця програма компілюється без помилок, і також скопмілювалася б, якби ви використали `word` після виклику `s.clear()`. `word` ніяк не пов'язане зі станом `s`, і тому `word` міститиме значення `5`. Ми можемо використати це значення `5` зі змінною `s`, щоб спробувати видобути з неї перше слово, але це буде помилкою, бо вміст `s` змінився відколи ми зберегли `5` до `word`.

Необхідність дбати про актуальність індексу в `word` відносно даних в `s` нудно і може спровокувати помилки! Керування такими індексами стає ще більш ламким, якщо ми напишемо функцію `second_word`. Її сигнатура буде виглядати так:

```rust,ignore
fn second_word(s: &String) -> (usize, usize) {
```

Тепер ми відстежуємо початковий *і* кінцевий індекси, і ми маємо ще більше значень, обчислених з даних у конкретному стані, але ніяк не прив'язаних до цього стану. Тепер ми маємо три непов'язані змінні, підвішені в повітрі, які нам треба тримати синхронізованими.

На щастя, у Rust є рішення цієї проблеми: зрізи стрічок.

### Зрізи стрічок

*Зріз стрічки* - це посилання на частину стрічки `String`, і виглядає воно так:

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

Це схоже на посилання на всю стрічку `String`, але з додатковим шматком `[0..5]`. Замість того, щоб посилатися на всю `String`, воно посилається на внутрішню частину в `String` і число елементів, яких воно стосується.

Ми створюємо зрізи з межами `[початковий_індекс..кінцевий_індекс]`, але структура даних зрізу насправді зберігає початкову позицію і довжину зрізу. Тому у випадку `let world = &s[6..11];`, `world` буде зрізом, що складається зі вказівника на 6-й байт `s` і довжини 5.

Рисунок 4-12 показує це як діаграму.

<figure>
<img alt="world містить вказівник на 6-й байт стрічки s і довжину 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />

<figcaption>

Рисунок 4-12: зріз стрічки, що посилається на частину `String`.

</figcaption>
</figure>

Синтаксис меж `..` у Rust дозволяє, якщо ви хочете почати зріз на початковому індексі (нуль), пропустити значення перед крапками. Іншими словами, ці рядки тотожні:

```rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
```

Так само якщо ваш зріз включає останній байт стрічки, ви можете пропустити останнє число. Таким чином, ці рядки також тотжні:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```

Також можна пропустити обидва значення, щоб взяти зріз з усієї стрічки. Це також тотожні рядки:

```rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

Озброєні цими знаннями, перепишемо `first_word`, щоб вона повертала зріз. Тип, що позначає зріз стрічки, записується як `&str`:

<span class="filename">Файл: src/main.rs</span>

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

Ми отримуємо індекс кінця слова тим же чином, що й у Роздруку 4-10, пошуком першого стрічного пробілу. Коли ми знаходимо пробіл, ми повертаємо зріз стрічки за допомогою початку стрічки і індексу знайденого пробілу як початкового і кінцевого індексів.

Тепер при виклику `first_word` ми отримаємо одне значення, пов'язане з даними. Значення складається з посилання на початкову точку зрізу і кількість елементів у зрізі.

Повернення зрізу також спрацює для функції `second_word`:

```rust,ignore
fn second_word(s: &String) -> &str {
```

Тепер ми маємо нехитрий API, з яким значно складніше потрапити в халепу, оскільки компілятор забезпечіть коректність посилань на стрічку. Пам'ятаєте помилку в програмі з Роздруку 4-11, коли ми мали індекс кінця першого слова, але очистили стрічку, чим зробили наш індекс некоректним? Цей код мав логічну помилку, але не призводив до жодних негайних помилок. Проблеми з'явилися б надалі, якби ми спробували використовувати індекс першого слова з пустою стрічкою. Зрізи унеможливлюють цю помилку і дають знати про проблему в коді значно раніше. Використання зрізової версії `first_word` призведе до помилки під час компіляції:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // Помилка!
}
```

Ось текст помилки компілятора:

```text
17:6 error: cannot borrow `s` as mutable because it is also borrowed as
            immutable [E0502]
    s.clear(); // Error!
    ^
15:29 note: previous borrow of `s` occurs here; the immutable borrow prevents
            subsequent moves or mutable borrows of `s` until the borrow ends
    let word = first_word(&s);
                           ^
18:2 note: previous borrow ends here
fn main() {

}
^
```

Пригадаємо, що за правилами позичання, якщо ми маємо стале посилання на щось, ми не можемо робити нестале посилання на це ж. Оскільки `clear` має скоротити стрічку, він намагається взяти нестале посилання - невдало. Rust не тільки робить наш API простішим у використанні, а ще й усуває під час компіляції цілий клас помилок!

#### Стрічкові літерали є зрізами

Згадайте, що ми говорили про стрічкові літерали, збережені у двійковому файлі. Оскільки тепер ми вже знаємо про зрізи, ми можемо як слід зрозуміти стрічкові літерали:

```rust
let s = "Hello, world!";
```

Типом `s` є `&str`: це зріз, що вказує на конкретне місце в двійковому файлі. Це також є причиною, чому стрічкові літерали є сталими; `&str` є сталим посиланням.

#### Стрічкові зрізи як параметри

Знання того, що можна брати зрізи літералів і `String` веде нас до ще одного поліпшення `first_word`. Її сигнатура наразі така:

```rust,ignore
fn first_word(s: &String) -> &str {
```

Більш досвідчений растацеанин напише замість цього такий рядок, бо він дозволяє нам використовувати одну й ту саму функцію і для `String` і для `&str`:

```rust,ignore
fn first_word(s: &str) -> &str {
```

Якшр у нас є стрічковий зріз, ми можемо передати його прямо. Якщо у нас є `String`, ми можемо передати зріз з усією стрічкою. Визначення функції, що приймає стрічковий зріз замість посилання на стрічку робить наш API більш загальним і корисним без втрати функціональності:

<span class="filename">Файл: src/main.rs</span>

```rust
# fn first_word(s: &str) -> &str {
#     let bytes = s.as_bytes();
#
#     for (i, &item) in bytes.iter().enumerate() {
#         if item == b' ' {
#             return &s[0..i];
#         }
#     }
#
#     &s[..]
# }
fn main() {
    let my_string = String::from("hello world");

    // first_word працює зі зрізами `String`а
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_word працює зі зрізами стрічкових літералів
    let word = first_word(&my_string_literal[..]);

    // оскільки стрічкові літерали *є* стрічковими зрізами
    // це також працює, без синтаксису зрізів!
    let word = first_word(my_string_literal);
}
```

### Інші зрізи

Стрічкові зрізи, як можна зрозуміти, пов'язані зі стрічками. Але є також і більш загальний тип зрізів. Розглянемо такий масив:

```rust
let a = [1, 2, 3, 4, 5];
```

Так само, як ми можемо захотіти звернутися до частини стрічки, ми можемо захотіти звернутися до частини масиву і зробити так:

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
```

Цей зріз має тип `&[i32]`. Він працює тим же чином, що й стрічкові зрізи, зберігаючи посилання на перший елемент і довжину. Цей тип зрізів можна використовувати для всіх інших видів колекцій. Ми поговоримо про ці колекції детальніше, коли будемо обговорювати вектори в Розділі 8.

## Висновки

Концепції власності, позичання, і зрізів - це те, що гарантує безпеку роботи із пам'яттю в програмах на Rust під час компіляції. Мова Rust надає вам контроль над використанням пам'яті так само, як і інші системні мови програмування, але те, що наявність власника даних автоматично призводить до очищення даних, коли власник виходить з області видимості, означає, що вам не треба писати і відлагоджувати додатковий код, щоб отримати цей контроль.

Власність впливає на те, як працює велика кількість інших частин Rust, тому ми говоритимемо про ці концепції і надалі у цій книзі. Перейдемо далі до наступного розділу і поглянемо на групування частинок даних докупи в структури `struct`.
