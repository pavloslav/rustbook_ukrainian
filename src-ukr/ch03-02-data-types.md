## Типи даних

Кожне значення в Rust має певний *тип*, який каже Rust, дані якого виду визначаються, щоб компілятор знав, як працювати з цими даними. У цьому підрозділі ми розберемо ряд типів, вбудованих у мову. Ми поділимо типи на дві категорії: скалярні і складені.

У цьому підрозділі майте на увазі, що Rust - *статично типізована* мова, тобто тип всіх змінних має бути відомим під час компіляції. Компілятор зазвичай може вивести, який тип ми хочемо використати, виходячи зі значення і того, як ми його використовуємо. У випадках, коли можливл багато типів, наприклад якщо ми перетворюємо стрічку `String` на число за допомогою `parse` у Розділі 2, треба додавати позначку типу:

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

Якщо ми не додамо позначку типу, Rust покаже помилку, яка означає, що компілятору треба більше інфомрації від нас, щоб зрозуміти, який з можливих типів ми хочемо використати:

```text
error[E0282]: unable to infer enough type information about `_`
 --> src/main.rs:2:5
  |
2 | let guess = "42".parse().expect("Not a number!");
  |     ^^^^^ cannot infer type for `_`
  |
  = note: type annotations or generic parameter binding required
```

Під час подальшого обговорення різних типів даних ви побачите різні позначки типів.

### Скалярні типи

*Скалярний* тип представляє єдине значення. У Rust є чотири первинні скалярні типи: цілі, числа з рухомою комою, булівські та символи. Ви, швидше за все, знаєте їх з інших мов програмування, але давайте поглянемо детальніше на їхню роботу в Rust.

#### Цілі типи

*Ціле* (*integer*) - це число без дробової частини. Ви використали один цілий тип раніше в цьому розділі, а саме `i32`. Оголошення цього типу означає, що асоційонване з ним значення має бути знаковим цілим (це і позначається `i` від англ. integer, на відміну від беззнакового `u` від англ. unsigned) для з 32 двійковими розрядами. Таблиця 3-1 показує вбудовані цілі типи в Rust. Кожен варіант в колонках "Знаковий" і "Беззнаковий" (наприклад, *i32*) може використовуватися для проголошення значення цілого типу.

<figure>
<figcaption>

Таблиця 3-1: Цілі типи в Rust

</figcaption>

| Довжина | Знаковий | Беззнаковий |
|---------|----------|-------------|
| 8 біт   | i8       | u8          |
| 16 біт  | i16      | u16         |
| 32 біти | i32      | u32         |
| 64 біти | i64      | u64         |
| архіт.  | isize    | usize       |

</figure>

Кожен варіант може бути знаковим чи беззнаковим і має явно зазначений розмір. "Знаковий" і "беззнаковий" стосується того, чи може число бути від'ємним чи лише додатним; іншими словами, чи має число знак (знакове) чи воно буде лише додатним і, відтак, буде представлене без знаку (беззнакове). Це як запис чисел на папері: якщо знак має значення, число записується зі знаком плюс чи знаком мінус; але, якщо можна вважати, що число буде додатним, воно записується без знаку. Знакові числа зберігаються у [доповняльному коді][compliment].

Кожен знаковий варіант може зберігати числа від -(2<sup>n - 1</sup>) до 2<sup>n - 1</sup> - 1 включно, де `n` - кількість біт, які цей варіант використовує. Так, `i8` може зберігати числа від -(2<sup>7</sup>) до 2<sup>7</sup> - 1, тобто від -128 до 127. Беззнакові варіанти зберігають числа від 0 до 2<sup>n</sup> - 1, так, `u8` може зберігати числа від 0 до 2<sup>8</sup> - 1, тобто від 0 до 255.

На додачу, типи `isize` та `usize` залежать від різновиду комп'ютера, на якому працює ваша програма: 64 біти, якщо це 64-бітна архітектура, чи 32 біти, якщо 32-бітна.

Ви можете писати цілі літерали в будь-якій формі, вказаній у Таблиці 3-2. Зверніть увагу, що всі числові літерали, крім байтових літералів, дозволяють використовувати суфікс типу на кшталт `57u8`, і `_` як роздільник для поліпшення читання, як-от `1_000` (те саме, що й `1000`).

<figure>
<figcaption>

Таблиця 3-2: Цілі літерали в Rust

</figcaption>

| Числові літерали   | Приклад       |
|--------------------|---------------|
| Десятковий         | `98_222`      |
| Шістнадцятковий    | `0xff`        |
| Вісімковий         | `0o77`        |
| Двійковий          | `0b1111_0000` |
| Байт (тільки `u8`) | `b'A'`        |

</figure>

Як же здогадатися, який тип цілого використати? Якщо ви непевні, типовий вібір Rust зазвичай непоганий, а типовий цилий тип в Rust - `i32`: він зазвичай найшвидший, навіть на 64-бітних системах. Основна ситуація, в якій варто використовувати `isize` та `usize` - індексація якого виду колекції.

#### Числа з рухомою комою

Також Rust має два первинні типи для *чисел з рухомою комою*, тобто чисел з десятковою комою. Числа з рухомою комою в Rust - це `f32` та `f64`, які мають розмір у 32 біти та 64 біти відповідно. Типовий тип - `f64`, оскільки його швидкість приблизно така ж сама, як і в `f32`, але він має вищу точність. На 32-бітних системах можна використовувати тип `f64`, але він буде повільнішим за `f32` на цих системах. У більшості випадків, вища точність краща за потенційно гіршу продуктивність, і варто провести оцінку часу виконання коду (англ. benchmark), якщо ви підозрюєте, що розмір чисел з рухомою комою створює проблему у вашій ситуації.

Ось приклад, що демонструє числа з рухомою комою у дії:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

Числа з рухомою комою представлені у відповідності зі страндартом IEEE-754. Тип `f32` є числом одинарної точності, а `f64` має подвійну точність.

#### Числові операції

Rust підтримує звичайні математичні операції, які ви очікуєте для будь-яких типів чисел: додавання, віднімання, множення, ділення і остача. Наступний код демонструє, як використовувати їх і інструкції `let`:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    // додавання
    let sum = 5 + 10;

    // віднімання
    let difference = 95.5 - 4.3;

    // множення
    let product = 4 * 30;

    // ділення
    let quotient = 56.7 / 32.2;

    // остача
    let remainder = 43 % 5;
}
```

Кожен вираз використовує математичну операцію і обчислює значення, яке прив'язується до змінної. Додаток B містить список усіх операцій, які використовуються в мові Rust.

#### Булівський тип

Як і в більшості інших мов програмування, булівський тип у Rust має два можливі значення: `true` ("істина") та `false` ("неправда"). Булівський тип у Rust позначається `bool`:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let t = true;

    let f: bool = false; // із явною позначкою типу
}
```

Основний спосіб використання булівських значень - умовні вирази, такі, як інструкція `if`. Про ці вирази розповідається в розділі "Управління потоком виконання".

#### Символьний тип

Досі ми працювали тільки з числами, але Rust підтримує також літери. Тип `char` в Rust є найпростішим алфавітним типом, і цей код демонструє один зі способів його використання:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
   let c = 'z';
   let z = 'ℤ';
   let heart_eyed_cat = '😻';
}
```
Тип `char` в Rust представляє Скалярне значення Юнікоду, тобто може представляти значно більше, ніж самий лише ASCII. Наголошені літери, китайські/японські/корейські ідеографи, емоджі, і пробіли нульової довжини є коректними значеннями типу `char` в Rust. Скалярні значення Юнікоду варіюються від `U+0000` до `U+D7FF` і від `U+E000` до `U+10FFFF` включно. Тим не менш, "символ" насправді не є концепцією Юнікоду, тому інтуїція стосовно того, що таке "символ" може не збігатися із `char` в Rust. Ми обговорюємо це питання детальніше у підрозділі "Стрічки" в Розділі 8.

### Складені типи

*Складені типи* дозволяють об'єднувати багато значень інших типів у один тип. Rust має два базових складених типи: кортежі (tuple) та масиви (array).

#### Об'єднання значень у кортежі

Кортеж - основний спосіб збирати до купи різні числа і інші значення *різних* типів у один складений тип.

Кортеж утворюється списком значень, розділених комою, в дужках. Кожна позиція в кортежі має тип, і типи різних значень у кортежі можуть різнитися. Ми додали необов'язкову позначку типу у цьому прикладі:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

Змінна `tup` зв'язується з усім кортежем, оскільки кортеж розглядається як єдиний складений елемент. Щоб отримати окремі значення з кортежу, можна скористатися співставлянням зі зразком, щоб деструктуризувати значення кортежу, на кшталт цього:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("Значення y: {}", y);
}
```

Ця програма спершу створює кортеж і прив'язує його до змінної `tup`. Потім вона використовує зразок із `let`, щоб взяти `tup` і перетворити його на три окремі змінні, `x`, `y` та `z`. Це зветься *деструктуризацією*, бо розбирає структуру кортежу на частини. Нарешті, програма виводить значення `y`, тобто `6.4`.

На додачу до деструктуризації через співставлення зі зразком, ми можемо також досягати елементів кортежу напряму через точку(`.`), за якою написаний індекс значення, яке ми хочемо отримати. Наприклад:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

Ця програма створює кортеж `x`, а потім створює нові змінні для кожного елементу за допомогою їхніх індексів. Як і в більшості мов програмування, перший індекс в кортежі - 0.

#### Масиви

Інший спосіб організувати колекцію з багатьох значень - це *масив*. На відміну від кортежу, всі елементи масиву мають один тип. Масиви в Rust відрізняються від масивів у деяких інших мовах, бо в Rust вони мають фіксовану довжину: після проголошення, їхній розмір не може зростати чи скорочуватися.

У Rust, значення, що потрапляють до масиву, пишуться у вигляді списку, розділеного комами, в квадратних дужках:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

Масиви корисні, коли дані мають бути розмішені в стеку, а не в купі (детальніше про це йдеться у Розділі 4), чи коли ви хочете бути певним, що завжди маєте фіксовану кількість елементів. Втім, масиви не такі гнучкі, як вектори. Вектор - це схожий тип-колекція, які можуть зростати і скорочуватися. Якщо ви не певні, використовувати вам масив чи вектор, швидше за все варто використати вектор. Детальніше про це можна прочитати у Розділі 8.

Приклад випадку, коли вам може знадобитися масив, а не вектор - програма, що використовує назви місяців року. Навряд чи така програма потребуватиме додавання чи усунення місяців, тому можна скористатися масивом, бо ви знаєте, що у ньому завжди буде 12 елементів:

```rust
let months = ["Січень",   "Лютий",   "Березень", "Квітень", 
              "Травень",  "Червень", "Липень",   "Серпень", 
              "Вересень", "Жовтень", "Листопад", "Грудень"];
```

##### Доступ до елементів масиву

Масив - це єдиний фрагмент пам'яті, віділений у стеку. До елементів масиву можна отримати доступ за допомогою індексації, ось так:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

У цьому прикладі, змінна з назвою `first` отримає значення `1`, бо це значення, розташоване за індексом `[0]` у масиві. Змінна з назвою `second` отримає значення `2` з індексу `[1]` в масиві.

##### Некоректний доступ до елементів масиву

Що станеться, якщо ми спробуємо дістатися до елементів масиву, що знаходяться за кінцем масиву? Змінимо приклад на такий:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let a = [1, 2, 3, 4, 5];

    let element = a[10];

    println!("Значення елементу: {}", element);
}
```

Запуск цього коду за допомогою `cargo run` видає такий результат:

```text
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/arrays` (exit code: 101)
```

Компіляція не повідомила про помилку, але програма аварійно завершилася помилкою *часу виконання*. Коли ви намагаєтеся отримати доступ до елементу масиву, Rust перевіряє, чи зазначений індекс менший за довжину масиву. Якщо індекс більший, Rust *панікує*, що в Rust означає, що програма завершується помилкою.

Це перший приклад принципів безпеки Rust у дії. В багатьох мовах нищького рівня такої перевірки не відбувається, і при запиті елементу з некоректним індексом, відбувається доступ до пам'яті за межами масиву. Rust захищає вас від такої помилки, одразу перериваючи роботу програми замість того, щоб дозволити некоректний доступ і продовжити роботу. Розділ 9 розповідає більше про обробку помилок у Rust.

[compliment]: https://uk.wikipedia.org/wiki/Доповняльний_код
