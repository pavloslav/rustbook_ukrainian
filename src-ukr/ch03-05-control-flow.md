## Управління потоком виконання

Рішення, виконувати чи ні певний код залежно від того, чи умова істинна, чи рішення повторити певний код кілька разів, доки умова істинна - базові будівельні елементи коду у більшості мов програмування. Найпоширеніші конструкції, що дозволяють вам управляти потоком виконання коду на Rust є вирази `if` та цикли.

### Вирази `if`

Вираз `if` дозволяє розгалужувати код у залежності від умов. Ми записуємо умову, а потім вказуємо: “Якщо ця умова дотримана, запусти цей блок коду. Якщо ж умова не дотримана, не запускай цей блок коду”.

Створіть новий проект з назвою *branches* у вашій теці *projects* для вправ із виразом `if`. У файл *src/main.rs* введіть таке:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("умова істинна");
    } else {
        println!("умова хибна");
    }
}
```

Всі вирази `if` починаються з ключового слова `if`, за яким іде умова. В цьому випадку умовою є порівняння, чи має змінна `number` значення, менше за 5. Блок коду, який ми хочемо виконати, якщо умова істинна, розміщується одразу після умови в фігурних дужках. Блоки коду, прив'язані до умов у виразах `if`, іноді звуть *рукавами*, так само, як рукави у виразах `match`, що ми обговорювали у секції "Порівняння здогадки з таємним числом" Розділу 2. Також можна додати необов'язковий вираз `else`, як тут, щоб надати програмі альтернативний блок коду для виконання, якщо умова виявиться хибною. Якщо ви не надасьте виразу `else`, а умова буде хибною, програма просто пропустить блок `if` і перейде до наступного фрагменту коду.

Спробуйте запустити цей код; ви маєте побачити, що він виведе таке:

```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
умова істинна
```

Тепер спробуємо змінити значення `number` на таке, що зробить умову `хибною`, і подивитися, що станеться:

```rust,ignore
let number = 7;
```

Запустіть програму і подивіться на вивід:

```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
умова хибна
```

Також варто зазначити, що умова в цьому коді *має* бути типу `bool`. Щоб побачити, що станеться, якщо умова не `bool`, спробуйте запустити такий код:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let number = 3;

    if number {
        println!("число є 3");
    }
}
```

Умова у виразі `if` обчислюється у значення `3`, і Rust повідомляє про помилку:

```text
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --> src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected bool, found integral variable
  |
  = note: expected type `bool`
  = note:    found type `{integer}`

error: aborting due to previous error
Could not compile `branches`.
```

Помилка показує, що Rust очікував `bool`, але виявив число. Rust не буде автоматично намагатися перетворити не-булівські типи в булівський, на відміну від таких мов, як Ruby чи JavaScript. Ви маєте завжди явно надавати виразу `if` умову типу `bool`. Якщо ми хочемо, щоб блок із кодом `if` виконувався тільки, скажімо, якщо число не дорівнює `0`, ми можемо змінити вираз `if` на такий:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let number = 3;

    if number != 0 {
        println!("число не дорівнює нулю");
    }
}
```

Виконання цього коду виведе `число не дорівнює нулю`.

#### Множинні умови з `else if`

Можливо обирати з багатьох умов, комбінуючи `if` та `else` у ланцюжок виразів `else if`. Нариклад:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("число ділиться на 4");
    } else if number % 3 == 0 {
        println!("число ділиться на 3");
    } else if number % 2 == 0 {
        println!("число ділиться на 2");
    } else {
        println!("число не ділиться на 4, 3, чи 2");
    }
}
```

Ця програма має чотири можливі шляхи. Після запуску, ви маєте побачити таке:

```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
число ділиться на 3
```

Коли ця програма виконується, вона перевіряє по черзі кожен вираз `if` і виконує перший блок, для якого умова справджується. Зверніть увагу, що, хоча 6 і ділиться на 2, ми не бачимо повідомлення `число ділиться на 2`, так само як і `число не ділиться на 4, 3, чи 2` з блоку `else` - бо Rust виконає тільки той блок, в якого першого буде істинна умова, а знайшовши його, не виконує його рукав `else` - а отже, навіть не перевіряє всю решту умов.

Забагато виразів `else if` можуть захарастити ваш код, тому, якщо вам треба більш ніж одна така конструкція, цілком можливо, що знадобиться рефакторизувати ваш код. У Розділі 6 описана потужна конструкція мови Rust для розгалуження, що зветься `match`, для таких випадків.

#### Використання `if` в інструкції `let`

Оскільки `if` є виразом, ми можемо використати його як праву частину інструкції `let`, за прикладом роздруку 3-4:

<figure>
<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("Значення числа: {}", number);
}
```

<figcaption>

Роздрук 3-4: Присвоєння значення виразу `if` змінній

</figcaption>
</figure>

Змінна `number` буде прив'язана до значення, залежно від результату обчислення виразу `if`. Запустіть цей код і подивіться, що відбудеться:

```text
$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
     Running `target/debug/branches`
Значення числа: 5
```

Нагадаємо, що значенням блоку коду є значення останнього виразу в них, а числа як такі самі є виразами. В цьому випадку, значення всього виразу `if` залежить від того, який блок коду буде виконано. Це означає, що значення, які можуть бути результатами у кожному рукаві `if` мають бути одного типу; у Роздруку 3-4, результати рукавів `if` та `else` є цілими числами типу `i32`. А що ж станеться, якщо типи не будуть збігатися, як у наступному прикладі?

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        "six"
    };

    println!("Значення числа: {}", number);
}
```

Якщо ми спробуємо запустити цей код, то отримаємо помилку. Рукави `if` та `else` мають несумісні типи значень, і Rust точно вказує, де шукати проблему в програмі:

```text
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: if and else have incompatible types
 --> src/main.rs:4:18
  |
4 |     let number = if condition {
  |                  ^ expected integral variable, found reference
  |
  = note: expected type `{integer}`
  = note:    found type `&’static str`
```

Вираз у блоці `if` обчислюється у ціле число, а вираз у блоці `else` обчислюється у стрічку. Це не працює, оскільки змінна мусить мати лише один тип. Rust має точно знати під час компіляції тип змінної `number`, щоб перевірити, що цей тип коректний усюди, де ця змінна використовується. Rust не зможе зробити це, якщо тип `number` буде визначений після запуску програми; компілятор був би складнішим і надавав би менше гарантій стосовно коду, якби мусив стежити за численими можливими типами кожної змінної.

### Повторення коду за допомогою циклів

Часто трапляється, що блок коду треба виконати більше одного разу. Для цього, Rust надає декілька *циклів*. Цикл виконує весь код тіла цикли до кінця, після чого починає спочатку. Для експериментів з циклами, зробімо новий проект під назвою *loops*.

У Rust є три види циклів: `loop`, `while` та `for`. Спробуємо кожен з них.

#### Повторення коду за допомогою `loop`

Ключове слово `loop` каже Rust виконувати блок коду знову і знову без кінця або ж доки не буде прямо сказано зупнитися.

Наприклад, замінимо вміст файлу *src/main.rs* в теці *loops* на такий:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    loop {
        println!("знову!");
    }
}
```

Якщо запустити цю програму, ми побачимо, що `знову!` виводиться неперервно раз у раз, доки ми не зупинимо програму вручну. Більшість терміналів підтримують клавіатурне скорочення Ctrl+C, яке зупиняє програму, що застрягла у нескінченому циклі. Давайте спробуємо:

```text
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
     Running `target/debug/loops`
знову!
знову!
знову!
знову!
^Cзнову!
```

Символи `^C` позначають, де ви натиснули Ctrl+C. Слово `знову!` може вивестися після `^C` чи ні, залежно від того, в який саме момент виконання коду був надісланий сигнал зупинки.

На щастя, Rust надає також інший, більш надійний спосіб перервати цикл. Ключове слово `break` може бути розміщене в циклі, щоб сказати програмі, коли припиняти виконувати цикл. Згадайте, що ми вже його використовували у грі "Відгадай число" в секції "Вихід після вдалої здогадки" Розділу 2, щоб вийти з програми, коли користувач вигравав у грі, відгадавши правильне число.

#### Умовні цикли за допомогою `while`

В програмах часто потрібно обчислювати умову в циклі. Доки умова істинна, цикл виконується. Коли умова припиняє бути істинною, можна викликати `break`, щоб зупинити цикл. Такий цикл можна реалізувати за допомогою комбінації `loop`, `if`, `else` та `break`; якщо бажаєте, можете спробувати зробити це зараз.

Втім, цей шаблон настільки часто зустрічається, що Rust має вбудовану конструкцію для цього, що зветься циклом `while`. Наступний приклад використовує `while`: програма повторюється три рази, зменшуючи число кожного разу. Потім, після циклу, вона виводить повідомлення і завершується:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let mut number = 3;

    while number != 0  {
        println!("{}!", number);

        number = number - 1;
    }

    println!("ЗАПУСК!!!");
}
```

Ця конструкція усуває багато вкладених конструкцій, які були б потрібні за використання `loop`, `if`, `else` та `break`, і вона зрозуміліша. Поки умова істинна, код виконується; в іншому разі, виходить з циклу.

#### Перебір колекції за допомогою `for`

Можна використовувати конструкцію `while`, щоб перебирати елементи колекції, такої, як масив. Наприклад:

<figure>
<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("значення: {}", a[index]);

        index = index + 1;
    }
}
```

<figcaption>

Роздрук 3-5: Перебір елементів колекції за допомогою циклу `while`

</figcaption>
</figure>

Тут код перелічує елементи масиву, починаючи з індекса `0`, і вивиодить кожен з них, доки не досягне останнього індекса в масиві (тобто коли `index < 5` вже не буде істинним). Виконання цього коду виведе всі елементи масиву:

```text
$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
     Running `target/debug/loops`
значення: 10
значення: 20
значення: 30
значення: 40
значення: 50
```

Всі п'ять значень з масиву з'являються на екрані, як і очікувано. Хоча `index` досягне значення `5`, виконання циклу припиняється до спроби отримати шосте значення з масиву.

Але такий підхід вразливий до помилок; ми можемо викликати паніку в програмі некоректним індексом. Також він повільний, оскільки компілятор додає код для перевірки коректності кожного елементу на кожній ітерації.

Більш ефективна альтернатива - цикл `for`, який виконує код для кожного елементу колекції. Цикл `for` виглядає так:

<figure>
<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("значення: {}", element);
    }
}
```

<figcaption>

Роздрук 3-5: Перебір елементів колекції за допомогою циклу `for`

</figcaption>
</figure>

Запустивши цей код ми побачимо такий самий вивід, як і в Роздруку 3-5. Що важливіше, ми збільшили безпеку коду і усунули можливість помилок - тепер неможливо, що код перейде за кінець масиву чи завершиться зарано, залишивши кілька значень необробленими.

Наприклад, у коді з Роздруку 3-5, якщо прибрати елемент з масиву `a`, але забути змінити умову на `while index < 4`, код призведе до паніки. За допомогою циклу `for` ви не забудете замінити інший код, якщо ви зміните кількість значень в масиві.

Безпечність і лаконічність циклів `for` робить їх найпоширенішою конструкцією циклів у Rust. Навіть у витуаціях, де треба виконати певний код визначену кількість разів, як у відліку з Роздруку 3-5, більшість растацеанців скористаються циклом `for`. Для цього треба буде скористатися типом `Range` ("діапазон"), який надається стандартною бібліотекою і генерує послідовно всі числа, починаючи з одного і закінчуючись перед іншим.

Ось як виглядає відлік, що використовує цикл `for` і ще один метод, про який ми ще не говорили, `rev`, для обернення діапазону:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("ЗАПУСК!!!");
}
```

Виглядає трохи краще, правда ж?

## Підсумок

Нарешті закінчили! Це був величенький розділ: ви вивчили змінні, звичайні вирази і вирази `if`, та ще цикли! Якщо ви хочете повправлятися з концепціями, обговореними у цьому розділі, спробуйте наприсати програми, що роблять таке:

* конвертуює температуру між шкалами Фаренгейта та Цельсія;
* обчислює n-е число Фібоначчі;
* виводить слова англійської різдвяної пісні "Дванадцять днів Різдва" з використанням повторень у пісні (якщо хочете - можете спробувати вивести казку "Ріпка").

Коли будете готові продовжувати, ми поговоримо про концепцію мови Rust, якої *немає* серед поширених серед інших мов програмування - володіння.
