## Як працюють функції

Функції використовуються скрізь у коді на Rust. Ви вже бачили одну з найважливіших функцій у мові - функцію `main`, яка є точкою входу багатьох програм. Ви також бачили ключове слово `fn`, яке дозволяє вам оголошувати нові функції.

У мові Rust для назв функцій і змінних прийнято використовувати *зміїний регістр* - тобто всі літери маленькі, а слова відокремлюються підкресленянми. Ось приклад програми, що містить визначення функції:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    println!("Привіт, світ!");

    another_function();
}

fn another_function() {
    println!("Інша функція.");
}
```

Визначення функцій у Rust починаються з `fn` і мають кілька пар дужок після назви функції. Фігурні дужки кажуть компілятору, де починається і закінчується тіло функції.

Ми можемо викликати будь-яку визначену нами функцію, написавши її назву і пару дужок. Оскільки `another_function` визначена в програмі, її можна викликати зсередини функції `main`. Зверніть увагу, що ми визначили `another_function` у сирцевому коді *після* функції `main`; так само її можна було визначити до функції `main`. Для Rust не має значення, де ви визначаєте функції, важливо, щоб вони були визначені хоч десь.

Почнемо новий бінарний проект з назвою *functions*, щоб глибше дослідити функції. Помістіть приклад `another_function` до файлу *src/main.rs* і запустіть його. Ви побачите таке:

```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
Привіт, світ!
Інша функція.
```

Рядки виконуються в порядку, в якому вони знаходяться в функції `main`. Спершу виводиться повідомлення “Привіт, світ!”, а потім викликається `another_function` і виводить своє повідомлення.

### Параметри функції

При визначення функціям можна визначати *параметри* - особливі змінні, що є частиною визначення функції. Коли функція має параметри, ми можемо надати функції конкретні значення для цих параметрів. Формально, конкретні значення звуться *аргументами* або *фактичними параметрами*, а параметри у визначенні функції - *формальними параметрами*, але зазвичай слова "параметр" та "аргумент" використовуються як для частини визначення функції, так і для конкретних значень, які були передані при виклику функції.

Це переписана версія `another_function` демонструє, як виглядають параметри в Rust:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("Значення x: {}", x);
}
```

Запустіть цю програму; ви маєте побачити таке:

```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
Значення x: 5
```

Проголошення `another_function` містить один параметр під назвою `x`. Тип `x` визначено як `i32`. Коли в `another_function` передається `5`, макрос `println!` виведе `5` на місце фігурних дужок у рядку формату.

У проголошенні функції ви *обов'язково* маєте проголошувати тип кожного параметру. Це свідоме рішення у дизайні мови Rust: вимога позначати тип у визначенні функції означає, що компілятору дуже рідко знадобиться просити вас використовувати їх де-інде ще в коді, щоб зрозуміти, який тип вам потрібен.

Якщо ви хочете, щоб у функції було багато параметрів, відокремлюйте проголошення параметрів комами, ось так:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!("Значення x: {}", x);
    println!("Значення y: {}", y);
}
```

Цей приклад створює функцію з двома параметрами, обидва мають тип `i32`. Функція виводить значення обох своїх параметрів. Звісно, параметрам функції зовсім не обов'язково мати один тип - просто так зроблено в цьому прикладі.

Спробуймо запустити цей код. Замініть програму у файлі *src/main.rs* вашого проекту *function* кодом вище, і запустіть його командою `cargo run`:

```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
Значення x: 5
Значення y: 6
```

Оскільки ми викликали функцію зі значенням `5` для параметру `x` і значенням `6` для `y`, обидві стрічки виведені зі цими значеннями.

### Тіла функцій

Тіла функцій складаються з послідовності інструкцій, яка може закінчуватися виразом. Поки що ми описували тільки функції без виразу наприкінці, але використовували вирази як частини інструкцій. Оскільки Rust є мовою, базованою на виразах, важливо розуміти цю відмінність. Інші мови можуть не мати таких відмінностей, тому давайте розглянемо, що таке інструкції і вирази і як різниця між ними впливає на тіла функцій.

### Інструкції і вирази

Насправді ми вже використовували інструкції і вирази. *Інструкції* (statement) - це команди, що виконують певні дії і не повертають значення. *Вирази* (expression) обчислюються, в результаті даючи певне значення. Розглянемо приклади.

Створення змінної і надання їй значення за допомогою ключового слова `let` - це інструкція. У Роздруку 3-3 `let y = 6;` є інструкцією:

<figure>
<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let y = 6;
}
```

<figcaption>

Listing 3-3: Проголошення функції `main`, що містить одну інструкцію.

</figcaption>
</figure>

Проголошення функцій - також інструкції; весь попередній приклад є однією складною інструкцією.

Інструкції не повертають значень. Таким чином, не можна присвоїти інструкцію `let` іншій змінній, на кшталт такого:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let x = (let y = 6);
}
```

При спробі запустити цю програму, ви отримаєте повідомлення про помилку:

```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
```

Інструкція `let y = 6` не повертає значення, тому немає нічого, з чим можна було б зв'язати `x`. Це відрізняється від інших мов, таких як C чи Ruby, де присвоєння повертає значення, яке воно присвоїло. В тих мовах можна написати `x = y = 6` і обидві змінні `x` та `y` набудуть значення `6`; у Rust так робити не можна.

Вирази Вирази обчислюються у певне значення і складають більшу частину решти коду, який ви писатимете на Rust. Розглянемо просту математичну операцію, таку, як `5 + 6`, яка є виразом, що обчислюється у значення `11`. Вирази можуть бути частинами інструкцій: у Роздруку 3-3 в інструкції `let y = 6;`, `6` - це вираз, що обчислюється у значення `6`. Виразами також є виклик функції чи макросу; блок, що створює нову область видимості, `{}` - це також вираз, наприклад:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("Значення y: {}", y);
}
```

Цей вираз:

```rust,ignore
{
    let x = 3;
    x + 1
}
```

є блоком, який, в цьому випадку, обчислюється у `4`. Це значення прив'язується до `y`, як частина інструкції `let`. Зверніть увагу на рядок без крапки з комою наприкінці блоку, на відміну від більшості рядків, які нам поки що траплялися. Вирази не мають крапки з комою наприкінці. Якщо ви додасьте крапу з комою в кінець виразу, ви зробите його інструкцією, яка не повертає значення. Пам'ятайте це, коли вивчатимете далі значення, які повертають функції та вирази.

### Функції і значення, які вони повертають

Функції можуть повертать значення в код, який їх викликав. Ці значення не мають власних імен, а їхній тип вказується після стрілочки (`->`). У Rust значення, що його повертає функція - це те саме, що значення останнього виразу в блоці - тілі функції. Ось приклад функції, що повертає значення:

<span class="filename">Файл: src/main.rs</span>

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("Значення x: {}", x);
}
```

У функції `five` немає викликів інших функцій, макросів чи навіть інструкцій `let` - тільки саме число `5`. Це коректна функція в мові Rust. Зверніть увагу, що тут зазначено тип значення, яке функція повертає - `-> i32`. Запустімо цей код; вивід має виглядати так:

```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
     Running `target/debug/functions`
Значення x: 5
```

`5` у `five` є значенням, яке повертає функція, і тому тип, який повертає функція - `i32`. Розглянемо це детальніше. Є два важливі моменти: по-перше, рядок `let x = five();` показує, що ми використовуємо значення, яке повернула функція, для ініціалізації змінної. Оскільки функція `five` повертає `5`, цей рядок робить те саме, що й такий:

```rust
let x = 5;
```

По-друге, функція `five` не має параматрів і визначає тип значення, яке вона повертає, але тіло функції складається лише з `5` без крапи з комою, оскільки значення цього виразу ми хочемо повернути. Подивимося інший приклад:

<span class="filename">Файл: src/main.rs</span>

```rust
fn main() {
    let x = plus_one(5);

    println!("Значення x: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

Якщо виконати цей код, він виведе `Значення x: 6`. Що ж станеться, якщо ми поставимо крапку з комою в кінець рядка `x + 1`, щоб він став інструкцією, а не виразом?

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
fn main() {
    let x = plus_one(5);

    println!("Значення x: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```

Виконання цього коду призводить до такої помилки:

```text
error[E0269]: not all control paths return a value
 --> src/main.rs:7:1
  |
7 | fn plus_one(x: i32) -> i32 {
  | ^
  |
help: consider removing this semicolon:
 --> src/main.rs:8:10
  |
8 |     x + 1;
  |          ^
```

Основне повідомлення про помилку “not all control paths return a value” (“не всі шляхи виконання повертають значення”) розкриває основну проблему цього коду. Визначення функції `plus_one` каже, що вона має повернути `i32`, але інструкції не обчислюються в значення. Таким чином, нічого не повертається, що суперечить визначенню функції й призводить до помилки. Далі, Rust повідомляє про можливість виправити цю проблему: він радить прибрати крапку з комою, що дійсно виправить помилку.