## Приймання параметрів командного рядка

Створімо новий проєкт за допомогою, як завжди, `cargo new`. Ми назвемо наш проєкт `minigrep`, щоб вирізнити його від інструменту `grep`, що вже може бути встановлено у вашій системі.

```console
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

Перше завдання - зробити, щоб `minigrep` приймав два параметри командного рядка: шлях до файлу і стрічка для пошуку. Тобто ми хочемо, щоб нашу програму можна було запускати за допомогою `cargo run`, двох рисок на позначення що подальші параметри стосуються нашої програми, а не `cargo`, стрічки для пошуку і шляху до файлу, в якому треба шукати, ось так:

```console
$ cargo run -- searchstring example-filename.txt
```

Наразі, програма, створена `cargo new`, не може обробляти параметри, передані їй. Певні бібліотеки з [crates.io](https://crates.io/) можуть допомогти писати програму, що приймає параметри командного рядка, але оскільки ви лише вивчаєте цю концепцію, запровадимо цю можливість самостійно.

### Читання значень параметрів

Щоб дозволити `minigrep` читати значення параметрів командного рядка, переданих йому, нам знадобиться функція `std::env::args` зі стандартної бібліотеки Rust. Ця функція поверне ітератор параметрів командного рядка, переданих `minigrep`. Детальніше про ітератори піде у [Розділі 13][ch13]<!-- ignore -->. Поки що вам лише треба знати про ітератори дві речі: ітератори створюють послідовність значень, і ми можемо викликати метод `collect` для ітератора, щоб перетворити його на колекцію, таку як вектор, що міститиме всі елементи, створені ітератором.

Код у Роздруку 12-1 дозволяє нашій програмі `minigrep` читати усі передані їй параметри командного рядка і зібрати значення у вектор.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-01/src/main.rs}}
```


<span class="caption">Роздрук 12-1: Збирання параметрів командного рядка у вектор і їхній друк</span>

Спершу ми вводимо модуль `std::env` до області видимості за допомогою інструкції `use`, щоб можна було скористатися функцію `args` з цього модуля. Зверніть увагу, що функція `std::env::args` розташована у модулі другого рівня. Як ми вже говорили у [Розділі 7][ch7-idiomatic-use]<!-- ignore -->, у цьому випадку, коли потрібна функція, вкладена глибше одного модуля, ми вирішили ввести її батьківський модуль в область видимості. Таким чином, ми зможемо легко використовувати інші функції з `std::env`. Також це дещо менш двозначне, ніж додавання `use std::env::args` і виклик функції як просто `args`, бо просто `args` можна легко переплутати з функцією, визначеною в поточному модулі.

> ### Функція `args` і некоректний юнікод
> 
> Зверніть увагу, що `std::env::args` запанікує, якщо якийсь із параметрів містить некоректний юнікод. Якщо вашій програмі треба приймати параметри з некоректним юнікодом, скористайтеся натомість функцією `std::env::args_os`. Вона повертає ітератор, що створює значення `OsString` замість `String`. Ми вирішили скористатися `std::env::args` для простоти, бо значення `OsString` різняться між платформами і з ними складніше працювати, ніж зі `String`.

У першому рядку `main` ми викликаємо `env::args` і одразу ж використовуємо `
collect`, щоб перетворити ітератор на вектор, що містить усі значення, вироблені ітератором. Ми можемо використати функцію `collect`, щоб створити багато видів колекцій, тому явно позначаємо тип `args`, щоб вказати, що нам потрібен вектор стрічок. Хоча в Rust дуже нечасто треба позначати типи, `collect` є однією з функцій, яка часто потребує позначок, бо Rust неспроможний вивести потрібний тип колекції.

В кінці ми друкуємо вектор за допомогою макроса для зневаджування. Спробуємо тепер запустити код спершу без параметрів, а тоді з двома параметрами:

```console
{{#include ../listings/ch12-an-io-project/listing-12-01/output.txt}}
```

```console
{{#include ../listings/ch12-an-io-project/output-only-01-with-args/output.txt}}
```

Зверніть увагу, що перше значення у векторі - `"target/debug/minigrep"`, тобто назва нашого двійкового файлу. Це відповідає поведінці списку параметрів у C, що дозволяє програмам використовувати ім'я, за яким їх викликано, під час виконання. Часто буває зручно мати доступ до імені програми якщо ви хочете роздрукувати його у повідомленнях чи змінити поведінку програми залежно від того, який псевдонім був використаний у командному рядку для запуску програми. Але задля потреб нашого розділу ми пропустимо його і збережемо лише два потрібні параметри.

### Збереження значень параметрів у змінних

Тепер програма може отримувати значення, вказані у параметрах командного рядка. Тепер нам треба зберегти значення двох параметрів у змінних, щоб можна було використати ці значення далі в програмі. Це ми робимо у Роздруку 12-2.

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-02/src/main.rs}}
```


<span class="caption">Роздрук 12-2: Створення змінних для збереження параметра - запиту і параметра - шляху до файла.</span>

Як ми бачили, коли роздрукували вектор, ім'я програми займає перше значення у векторі за індексом `args[0]`, тому ми починаємо параметри з індексу `1`. Перший параметр `minigrep` приймає шукану стрічку, тож ми розміщуємо посилання на перший параметр у змінній `query`. Другий параметр буде шляхом до файлу, тож ми розміщуємо посилання на другий параметр у змінній `file_path`.

Ми тимчасово роздруковуємо значення цих змінних, щоб підтвердити, що код працює, як ми очікували. Запустімо цю програму знову з параметрами `test` і `sample.txt`:

```console
{{#include ../listings/ch12-an-io-project/listing-12-02/output.txt}}
```

Чудово, програма працює! Значення потрібних нам параметрів зберігаються у правильних змінних. Пізніше ми додамо трохи обробки помилок, щоб розібратися з певними потенційними помилковими ситуаціями, на кшталт коли користувач не надає жодних параметрів; а поки що ігноруватимемо цю ситуацію і натомість займемося додаванням можливостей для читання файлів.

[ch13]: ch13-00-functional-features.html
[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths
