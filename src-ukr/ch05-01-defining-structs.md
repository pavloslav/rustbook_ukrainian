## Визначення і інстанціювання struct-ів

Структури подібні до кортежів, про які ми говорили в Розділі 3. Як і кортежі, частини структур можуть бути різних типів. На відміну від кортежів, ми даємо ім'я кожному елементу даних, щоб було зрозуміло, що ці значення означають. Завдяки цим іменам структури гнучкіші за кортежі: ми не мусимо покладатися на порядок даних, щоб визначати чи отримувати доступ до значень екземляра.

Для визначення структури, ми вводимо ключове слово `struct` і називаємо всю структуру. Ім'я структури має описувати сенс групування цих елементів даних. Потім, у фігурних дужках, ми визначаємо імена і типи елементів даних, які звуться *полями*. Наприклад, Роздрук 5-1 показує структуру, що зберігає інформацію про обліковий запис користувача:

```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
```

<span class="caption">Роздрук 5-1: Визначення структури `User`</span>

Щоб скористатися структурою по визначенню, ми створюємо *екземляр* цієї структури, визначаючи конкретні значення для кожного поля. Ми створюємо екземляр, вказуючи ім'я структури, а потім в фігурних дужках додаємо пари `ключ:
значення`, де ключі - це імена полів, а значення - дані, які ми хочемо зберігати в цих полях. Поля не обов'язково вказувати у тому ж порядку, в якому вони були проголошені в структурі. Іншими словами, визначення структури - це загальний шаблон типу, а екземпляри заповнюють цей шаблон конкретними даними, щоб створити значення цього типу. Наприклад, ми можемо проголосити конкретного користувача, як показано в Роздруку 5-2:

```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
```

<span class="caption">Роздрук 5-2: Створення екземпляру структури `User`</span>

Щоб отримати конкретне значення зі стріктури, можна скористатися записом через точку. Якщо ми хочемо отримати тільки адресу електронної пошти користувача, ми можемо написати `user1.email` там, де нам потрібне це значення. Якщо екземпляр є несталим, ми можемо змінити значення за допомогою запису через точку і присвоюванням конкретному полю. Роздрук 5-3 показує, як змінити значення поля `email` несталого екземпляру `User`:

```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
let mut user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from("anotheremail@example.com");
```


<span class="caption">Роздрук 5-3: Зміна значення поля `email` екземпляру `User` instance</span>

Зверніть увагу, що несталим має бути весь екземпляр; Rust не дозволяє позначати лише окремі поля як несталі. Також зверніть увагу, що, як і з будь-яким виразом, ми можемо написати новий екземпляр останнім виразом у тілі функції, щоб неявно повернути цей новий екземпляр.

Роздрук 5-4 демонструє функцію `build_user`, що повертає екземпляр `User` зі встановленими адресою і ім'ям. Поле `active` отримує значення `true`, а `sign_in_count` - значення `1`.

```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
```


<span class="caption">Роздрук 5-4: Функція `build_user`, що приймає адресу і ім'я і повертає екземпляр `User`</span>

Має сенс називати аргументи такої функції тими ж іменами, що й імена відповідних полів стурктури, але необхідність повторювати імена полів `email` та `username` утомлює. Якщо у структури більше полів, повторення кожного імені дратує ще більшу. На щастя, є зручне скорочення!

### Використання скорочення ініціалізації полів, коли змінні і поля однаково
### звуться

Оскільки імена параметрів і полів структури повністю збігаються в Родруку 5-4, ми можемо скористатися синтаксисом *скорочення ініціалізації полів* і переписати `build_user`, щоб вона робила абсолютно те саме, але без повторень `email` та `username`, як показано в Роздруку 5-5.

```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```


<span class="caption">Роздрук 5-5: Функція `build_user`, що використовує скорочення ініціалізації полів, оскільки параметри `email` та `username` мають ті ж назви, що й поля структури</span>

Ми створюємо новий екземпляр структури `User`, яка має поле з назовою `email`. Ми хочемо встановити значення поля `email` у значення параметру `email` функції `build_user`. Оскільки поле `email` і параметри `email` мають одну назву, можна писати скорочено `email` замість `email: email`.

### Створення екземплярів з інших екземплярів за допомогою синтасису оновлення
### структури

Часто буває корисним створити новий екземпляр структури, що бере більшу частину даних з екземпляру, що вже існує, проте деякі змінює. Це робить за допомогою *синтаксису оновлення структури*.

Для початку, Роздрук 5-6 показує, як створити новий езкемпляр `User`, що зветься `user2`, без синтаксису оновлення. Ми виставляємо нові значення полів `email` та `username`, проте решта використовує значення зі структури `user`, створеної у Роздруку 5-2:

```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from("someone@example.com"),
#     username: String::from("someusername123"),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
```


<span class="caption">Роздрук 5-6: Створення нового екземпляру `User` з деякими значеннями з `user1`</span>

Синтаксис оновлення структури дає той самий результат із меншою кількістю коду, як показано у Роздруку 5-7. Запис `..` позначає, що решта полів, що їх не було явно виставлено, отримають ті значення, що були в заданому екземплярі.

```rust
# struct User {
#     username: String,
#     email: String,
#     sign_in_count: u64,
#     active: bool,
# }
#
# let user1 = User {
#     email: String::from("someone@example.com"),
#     username: String::from("someusername123"),
#     active: true,
#     sign_in_count: 1,
# };
#
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
```


<span class="caption">Роздрук 5-7: Використання синтаксису оновлення структури для задання нових значень `email` та `username` екземпляру структури `User`, решту значень полів взято зі змінної `user1`</span>

Код у Роздруку 5-7 також створює екземпляр `user2`, що має відмінні значення `email` та `username`, але має ті ж значення `active` та `sign_in_count`, що й `user1`.

### Структури-кортежі без іменованих полів для створення різних типів

Ми також можемо визначати структури, які виглядають схожими на кортежі, що звуться *структури-кортежі* (*tuple struct*). Вони надають значення структурі, бо мають назву, але не мають назв полів, тільки типи. Структури-кортежі корисні, коли ви хочете дати кортежу ім'я і зробити кортеж окремим типом, але називати кожне поле, як у звичайній структурі, буде надто багатослівним чи надмірним.

Щоб визначити структуру-кортеж, треба вказати ключове слово `struct` і ім'я структури, а потім типи в кортежі. Наприклад, ось визначення і приклади застосування двох структур-кортежів, що звуться `Color`(колір) і `Point`(точка):

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

Зауважте, що значення `black` та `origin` мають різні типи, бо вони є екземплярами різних структур-кортежів. Кожна визначена нами структура має свій власний тип, навіть якщо поля структур мають однакові типи. Наприклад, функція, що приймає параметр типу `Color`, не може прийняти аргументом `Point`, хоча обидва типи складаються з трьох значень `i32`. В іншому ж структури-кортежі поводяться як кортежі, про які ми говорили в Розділі 3: ви можете деструктуризувати їх на окремі шматки, ви можете використовувати `.` з індексом, щоб отримати доступ до окремого значення і так далі.

### Одинично-подібні структури без полів

Також можна визначати структури без жодних полів! Вони звуться *одинично-подібні структури* (*unit-like struct*), бо поводяться аналогічно до `()`, одничного типу. Одинично-подібні структури можуть бути корисними в ситуаціях, коли вам потрібно втілити рису до якогось типу, але у вас немає потреби зберігати якісь дані. Риси будуть обговорюватися в Розділі 10.

> ### Володіння даними структури
> 
> В структурі `User` з Роздруку 5-1 ми використовували тип `String`, що має володіння, а не стрічковий зріз `&str`. Це свідомий вибір, бо ми хочемо, щоб екземпляри цієї структури володіли всіма даними і щоб ці дані були коректні весь час існування структури в цілому.
> 
> Структура також може зберігати посилання на дані, якими володіє хтось інший, але це потребує використання *часу життя*, особливості Rust, що обговорюється у Розділі 10. Час життя гарантує, що дані, на які посилається структура, будуть коректними весь час існування структури. Наприклад, якщо ви спробуєте зберегти посилання у структурі без уточнення часу життя, ось так:
> 
> <span class="filename">Файл: src/main.rs</span>
> 
> ```rust,ignore
> struct User {
>     username: &str,
>     email: &str,
>     sign_in_count: u64,
>     active: bool,
> }
> 
> fn main() {
>     let user1 = User {
>         email: "someone@example.com",
>         username: "someusername123",
>         active: true,
>         sign_in_count: 1,
>     };
> }
> ```
> 
> Компілятор повідомить, що йому потрібно вказати час життя:
> 
> ```text
> error[E0106]: missing lifetime specifier
>  -->
>   |
> 2 |     username: &str,
>   |               ^ expected lifetime parameter
> 
> error[E0106]: missing lifetime specifier
>  -->
>   |
> 3 |     email: &str,
>   |            ^ expected lifetime parameter
> ```
> 
> Ми обговоримо, як це виправити, щоб можна було зберігати посилання у структурах, у Розділі 10, а поки що, будемо виправляти подібні помилки за допомогою типів, що володіють своїми даними, на кшталт `String`, замість посилань на кшталт `&str`.
